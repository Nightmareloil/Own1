-- 2take1 Hub - Fixed and Improved Version
-- All bugs fixed, commands work properly in chat

repeat wait() until game.Players.LocalPlayer

-- Services
local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local TextChatService = game:GetService("TextChatService")

-- Variables
local player = Players.LocalPlayer
local load = workspace:WaitForChild("load"):WaitForChild("RemoteEvent")

-- Configuration
local Config = {
    speed = 5,
    range = 15,
    walkSpeed = 16,
    jumpPower = 50,
    flySpeed = 50,
    commandPrefix = ";",
    autoEquipSword = true,
    debugMode = false
}

-- State Management
local State = {
    fastFarm = false,
    slowFarm = false,
    godMode = false,
    killAura = false,
    flying = false,
    noclip = false,
    guiOpen = true,
    focused = false,
    initialized = false
}

-- Data Storage
local Data = {
    admins = {},
    commandHistory = {},
    historyIndex = 0,
    flyObjects = {},
    connections = {},
    currentSword = nil
}

-- Theme
local Theme = {
    background = Color3.fromRGB(25, 25, 25),
    secondary = Color3.fromRGB(35, 35, 35),
    tertiary = Color3.fromRGB(45, 45, 45),
    accent = Color3.fromRGB(88, 101, 242),
    text = Color3.fromRGB(255, 255, 255),
    textDim = Color3.fromRGB(180, 180, 180),
    success = Color3.fromRGB(87, 242, 135),
    danger = Color3.fromRGB(237, 66, 69),
    warning = Color3.fromRGB(255, 193, 7)
}

-- UI Variable
local GUI = {}

-- Utility Functions
local function debugPrint(message)
    if Config.debugMode then
        print("[2take1 Hub Debug] " .. tostring(message))
    end
end

local function createTween(object, properties, duration)
    if not object or not object.Parent then return end
    return TweenService:Create(object, TweenInfo.new(duration or 0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), properties)
end

local function safeDestroy(object)
    if object and object.Parent then
        object:Destroy()
    end
end

local function notification(text, notificationType)
    notificationType = notificationType or "info"
    local colors = {
        info = Theme.accent,
        success = Theme.success,
        error = Theme.danger,
        warning = Theme.warning
    }
    
    if not GUI.screenGui or not GUI.screenGui.Parent then return end
    
    local notif = Instance.new("Frame")
    notif.Size = UDim2.new(0, 300, 0, 60)
    notif.Position = UDim2.new(1, -320, 0, 20)
    notif.BackgroundColor3 = Theme.secondary
    notif.BorderSizePixel = 0
    notif.ZIndex = 1000
    notif.Parent = GUI.screenGui
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = notif
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = colors[notificationType]
    stroke.Thickness = 2
    stroke.Parent = notif
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, -20, 1, -10)
    textLabel.Position = UDim2.new(0, 10, 0, 5)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = text
    textLabel.TextColor3 = Theme.text
    textLabel.TextSize = 12
    textLabel.Font = Enum.Font.Gotham
    textLabel.TextWrapped = true
    textLabel.TextXAlignment = Enum.TextXAlignment.Left
    textLabel.TextYAlignment = Enum.TextYAlignment.Center
    textLabel.Parent = notif
    
    -- Animate in
    notif.Position = UDim2.new(1, 20, 0, 20)
    local tweenIn = createTween(notif, {Position = UDim2.new(1, -320, 0, 20)})
    if tweenIn then tweenIn:Play() end
    
    -- Auto-remove after delay
    task.spawn(function()
        wait(4)
        if notif and notif.Parent then
            local tweenOut = createTween(notif, {Position = UDim2.new(1, 20, 0, 20)})
            if tweenOut then 
                tweenOut:Play()
                tweenOut.Completed:Connect(function()
                    safeDestroy(notif)
                end)
            else
                safeDestroy(notif)
            end
        end
    end)
end

-- Enhanced Player Finding
local function findPlayer(name)
    if not name or name == "" then return nil end
    name = name:lower()
    
    debugPrint("Finding player: " .. name)
    
    -- Special cases
    if name == "me" then return player end
    if name == "all" then return Players:GetPlayers() end
    if name == "others" then
        local others = {}
        for _, p in pairs(Players:GetPlayers()) do
            if p ~= player then
                table.insert(others, p)
            end
        end
        return others
    end
    
    -- Find by exact name first
    for _, p in pairs(Players:GetPlayers()) do
        if p.Name:lower() == name then
            return p
        end
    end
    
    -- Find by display name
    for _, p in pairs(Players:GetPlayers()) do
        if p.DisplayName:lower() == name then
            return p
        end
    end
    
    -- Find by partial match
    for _, p in pairs(Players:GetPlayers()) do
        if p.Name:lower():find(name) or p.DisplayName:lower():find(name) then
            return p
        end
    end
    
    return nil
end

-- Enhanced Sword System
local function getSwordHandle()
    local sword = nil
    
    -- Check if already equipped
    if player.Character then
        sword = player.Character:FindFirstChildOfClass("Tool")
    end
    
    -- Get from backpack if not equipped
    if not sword and player.Backpack then
        sword = player.Backpack:FindFirstChildOfClass("Tool")
        if sword and player.Character and player.Character:FindFirstChild("Humanoid") then
            local success = pcall(function()
                player.Character.Humanoid:EquipTool(sword)
            end)
            if not success then
                debugPrint("Failed to equip sword")
            end
        end
    end
    
    -- Request new sword if none found
    if not sword then
        debugPrint("No sword found, requesting new one")
        pcall(function()
            load:FireServer()
        end)
        
        task.wait(0.5)
        
        if player.Backpack then
            sword = player.Backpack:FindFirstChild("sword") or player.Backpack:FindFirstChildOfClass("Tool")
            if sword and player.Character and player.Character:FindFirstChild("Humanoid") then
                pcall(function()
                    player.Character.Humanoid:EquipTool(sword)
                end)
            end
        end
    end
    
    Data.currentSword = sword
    return sword and sword:FindFirstChild("Handle")
end

-- Admin System
local function isAdmin(plr)
    if plr == player then return true end -- Owner is always admin
    
    for _, adminName in pairs(Data.admins) do
        if plr.Name:lower() == adminName:lower() then
            return true
        end
    end
    return false
end

local function addAdmin(plr)
    if not isAdmin(plr) then
        table.insert(Data.admins, plr.Name)
        notification("Added " .. plr.Name .. " as admin", "success")
        return true
    end
    return false
end

local function removeAdmin(plr)
    if plr == player then return false end -- Can't remove owner
    
    for i, adminName in pairs(Data.admins) do
        if adminName:lower() == plr.Name:lower() then
            table.remove(Data.admins, i)
            notification("Removed " .. plr.Name .. " from admin", "info")
            return true
        end
    end
    return false
end

-- Enhanced Message System
local function sendChatMessage(message)
    local success = false
    
    -- Try TextChatService first (new chat system)
    if TextChatService and TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
        pcall(function()
            local textChannels = TextChatService:FindFirstChild("TextChannels")
            if textChannels then
                local rbxGeneral = textChannels:FindFirstChild("RBXGeneral")
                if rbxGeneral and rbxGeneral.SendAsync then
                    rbxGeneral:SendAsync("[2take1 Hub] " .. message)
                    success = true
                elseif rbxGeneral and rbxGeneral.DisplaySystemMessage then
                    rbxGeneral:DisplaySystemMessage("[2take1 Hub] " .. message)
                    success = true
                end
            end
        end)
    end
    
    -- Try legacy chat system
    if not success then
        pcall(function()
            local chatEvents = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
            if chatEvents then
                local sayMessageRequest = chatEvents:FindFirstChild("SayMessageRequest")
                if sayMessageRequest then
                    sayMessageRequest:FireServer("[2take1 Hub] " .. message, "All")
                    success = true
                end
            end
        end)
    end
    
    -- Fallback to notification
    if not success then
        notification(message, "info")
    end
    
    debugPrint("Sent message: " .. message .. " (Success: " .. tostring(success) .. ")")
end

-- Enhanced Command System
local function executeCommand(command, executor)
    if not command or command == "" then return end
    
    local args = {}
    for word in command:gmatch("%S+") do
        table.insert(args, word:lower())
    end
    
    if #args == 0 then return end
    
    local cmd = args[1]
    debugPrint("Executing command: " .. cmd .. " by " .. executor.Name)
    
    -- Permission check for protected commands
    local protectedCommands = {
        "kill", "god", "tp", "bring", "dmg", "damage", "admin", "unadmin"
    }
    
    local isProtected = false
    for _, protectedCmd in pairs(protectedCommands) do
        if cmd == protectedCmd then
            isProtected = true
            break
        end
    end
    
    if isProtected and not isAdmin(executor) then
        notification(executor.Name .. " tried to use admin command: " .. cmd, "warning")
        return
    end
    
    -- Commands
    if cmd == "cmds" or cmd == "commands" then
        local commandList = ""
        if executor == player then
            commandList = "OWNER COMMANDS: kill, god, dmg, tp, bring, admin, unadmin, fly, noclip, speed, jp, reset, ff, sf, godmode, kaura, rejoin, cmds"
        elseif isAdmin(executor) then
            commandList = "ADMIN COMMANDS: kill, god, dmg, tp, bring, fly, noclip, speed, jp, reset, ff, sf, godmode, kaura, rejoin, cmds"
        else
            commandList = "USER COMMANDS: fly, noclip, speed, jp, reset, ff, sf, godmode, kaura, rejoin, cmds"
        end
        
        sendChatMessage(commandList)
        
    elseif cmd == "admin" then
        if executor ~= player then
            notification("Only owner can add admins", "error")
            return
        end
        
        local target = findPlayer(args[2])
        if target and type(target) == "userdata" then
            if addAdmin(target) then
                sendChatMessage(target.Name .. " is now Admin!")
            else
                sendChatMessage(target.Name .. " is already Admin!")
            end
        else
            notification("Player not found", "error")
        end
        
    elseif cmd == "unadmin" then
        if executor ~= player then
            notification("Only owner can remove admins", "error")
            return
        end
        
        local target = findPlayer(args[2])
        if target and type(target) == "userdata" then
            if removeAdmin(target) then
                sendChatMessage(target.Name .. " is no longer Admin!")
            else
                sendChatMessage(target.Name .. " is not an Admin!")
            end
        else
            notification("Player not found", "error")
        end
        
    elseif cmd == "admins" then
        if #Data.admins == 0 then
            sendChatMessage("Current Admins: None (Owner: " .. player.Name .. ")")
        else
            sendChatMessage("Current Admins: " .. table.concat(Data.admins, ", ") .. " (Owner: " .. player.Name .. ")")
        end
        
    elseif cmd == "kill" then
        task.spawn(function()
            local handle = getSwordHandle()
            if not handle or not handle:FindFirstChild("dmg") then
                notification("No sword equipped", "error")
                return
            end
            
            local targets = {}
            local targetName = args[2] or "me"
            
            if targetName == "all" then
                targets = Players:GetPlayers()
            elseif targetName == "others" then
                for _, plr in pairs(Players:GetPlayers()) do
                    if plr ~= executor then
                        table.insert(targets, plr)
                    end
                end
            else
                local target = findPlayer(targetName)
                if target then
                    if type(target) == "table" then
                        targets = target
                    else
                        targets = {target}
                    end
                else
                    notification("Player not found: " .. targetName, "error")
                    return
                end
            end
            
            local killedCount = 0
            for _, plr in pairs(targets) do
                if plr.Character and plr.Character:FindFirstChild("Humanoid") then
                    pcall(function()
                        handle.dmg.RemoteEvent:FireServer(plr.Character.Humanoid, math.huge)
                        killedCount = killedCount + 1
                    end)
                    task.wait(0.1)
                end
            end
            
            sendChatMessage(executor.Name .. " killed " .. killedCount .. " players")
        end)
        
    elseif cmd == "god" then
        task.spawn(function()
            local handle = getSwordHandle()
            if not handle or not handle:FindFirstChild("dmg") then
                notification("No sword equipped", "error")
                return
            end
            
            local targets = {}
            local targetName = args[2] or "me"
            
            if targetName == "all" then
                targets = Players:GetPlayers()
            elseif targetName == "others" then
                for _, plr in pairs(Players:GetPlayers()) do
                    if plr ~= executor then
                        table.insert(targets, plr)
                    end
                end
            elseif targetName == "me" then
                targets = {executor}
            else
                local target = findPlayer(targetName)
                if target then
                    if type(target) == "table" then
                        targets = target
                    else
                        targets = {target}
                    end
                else
                    notification("Player not found: " .. targetName, "error")
                    return
                end
            end
            
            local goddedCount = 0
            for _, plr in pairs(targets) do
                if plr.Character and plr.Character:FindFirstChild("Humanoid") then
                    pcall(function()
                        for i = 1, 10 do
                            handle.dmg.RemoteEvent:FireServer(plr.Character.Humanoid, -math.huge)
                            task.wait(0.05)
                        end
                        goddedCount = goddedCount + 1
                    end)
                    task.wait(0.1)
                end
            end
            
            sendChatMessage(executor.Name .. " godded " .. goddedCount .. " players")
        end)
        
    elseif cmd == "dmg" or cmd == "damage" then
        task.spawn(function()
            local handle = getSwordHandle()
            if not handle or not handle:FindFirstChild("dmg") then
                notification("No sword equipped", "error")
                return
            end
            
            local targetName = args[2] or "me"
            local percentage = tonumber(args[3]) or 50
            percentage = math.clamp(percentage, 1, 99)
            
            local targets = {}
            
            if targetName == "all" then
                targets = Players:GetPlayers()
            elseif targetName == "others" then
                for _, plr in pairs(Players:GetPlayers()) do
                    if plr ~= executor then
                        table.insert(targets, plr)
                    end
                end
            else
                local target = findPlayer(targetName)
                if target then
                    if type(target) == "table" then
                        targets = target
                    else
                        targets = {target}
                    end
                else
                    notification("Player not found: " .. targetName, "error")
                    return
                end
            end
            
            local damagedCount = 0
            for _, plr in pairs(targets) do
                if plr.Character and plr.Character:FindFirstChild("Humanoid") then
                    pcall(function()
                        local humanoid = plr.Character.Humanoid
                        local damage = (humanoid.MaxHealth * percentage) / 100
                        handle.dmg.RemoteEvent:FireServer(humanoid, damage)
                        damagedCount = damagedCount + 1
                    end)
                    task.wait(0.1)
                end
            end
            
            sendChatMessage(executor.Name .. " damaged " .. damagedCount .. " players by " .. percentage .. "%")
        end)
        
    elseif cmd == "tp" or cmd == "goto" then
        local target = findPlayer(args[2])
        if target and type(target) == "userdata" and target.Character and target.Character:FindFirstChild("HumanoidRootPart") and 
           executor.Character and executor.Character:FindFirstChild("HumanoidRootPart") then
            executor.Character.HumanoidRootPart.CFrame = target.Character.HumanoidRootPart.CFrame
            sendChatMessage(executor.Name .. " teleported to " .. target.Name)
        else
            notification("Cannot teleport to target", "error")
        end
        
    elseif cmd == "bring" then
        local target = findPlayer(args[2])
        if target and type(target) == "userdata" and target.Character and target.Character:FindFirstChild("HumanoidRootPart") and 
           executor.Character and executor.Character:FindFirstChild("HumanoidRootPart") then
            target.Character.HumanoidRootPart.CFrame = executor.Character.HumanoidRootPart.CFrame
            sendChatMessage(executor.Name .. " brought " .. target.Name)
        else
            notification("Cannot bring target", "error")
        end
        
    elseif cmd == "fly" then
        if executor ~= player then
            notification("Fly command only works for script owner", "error")
            return
        end
        
        if not State.flying then
            State.flying = true
            local character = executor.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                local rootPart = character.HumanoidRootPart
                
                -- Clean up old fly objects
                for _, obj in pairs(Data.flyObjects) do
                    safeDestroy(obj)
                end
                Data.flyObjects = {}
                
                local bodyVelocity = Instance.new("BodyVelocity")
                bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                bodyVelocity.Parent = rootPart
                
                local bodyGyro = Instance.new("BodyGyro")
                bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                bodyGyro.D = 2000
                bodyGyro.P = 10000
                bodyGyro.CFrame = rootPart.CFrame
                bodyGyro.Parent = rootPart
                
                Data.flyObjects = {bodyVelocity, bodyGyro}
                
                notification("Fly enabled", "success")
                
                -- Fly control loop
                if Data.connections.flyControl then
                    Data.connections.flyControl:Disconnect()
                end
                
                Data.connections.flyControl = RunService.Heartbeat:Connect(function()
                    if not State.flying or not character.Parent or not bodyVelocity.Parent then
                        return
                    end
                    
                    local camera = workspace.CurrentCamera
                    local moveVector = Vector3.new(0, 0, 0)
                    
                    if UIS:IsKeyDown(Enum.KeyCode.W) then
                        moveVector = moveVector + camera.CFrame.LookVector
                    end
                    if UIS:IsKeyDown(Enum.KeyCode.S) then
                        moveVector = moveVector - camera.CFrame.LookVector
                    end
                    if UIS:IsKeyDown(Enum.KeyCode.A) then
                        moveVector = moveVector - camera.CFrame.RightVector
                    end
                    if UIS:IsKeyDown(Enum.KeyCode.D) then
                        moveVector = moveVector + camera.CFrame.RightVector
                    end
                    if UIS:IsKeyDown(Enum.KeyCode.Space) then
                        moveVector = moveVector + Vector3.new(0, 1, 0)
                    end
                    if UIS:IsKeyDown(Enum.KeyCode.LeftShift) then
                        moveVector = moveVector - Vector3.new(0, 1, 0)
                    end
                    
                    bodyVelocity.Velocity = moveVector * Config.flySpeed
                    bodyGyro.CFrame = camera.CFrame
                end)
            end
        else
            notification("Fly already enabled", "warning")
        end
        
    elseif cmd == "unfly" then
        if executor ~= player then
            notification("Unfly command only works for script owner", "error")
            return
        end
        
        State.flying = false
        
        if Data.connections.flyControl then
            Data.connections.flyControl:Disconnect()
            Data.connections.flyControl = nil
        end
        
        for _, obj in pairs(Data.flyObjects) do
            safeDestroy(obj)
        end
        Data.flyObjects = {}
        
        notification("Fly disabled", "success")
        
    elseif cmd == "noclip" then
        if executor ~= player then
            notification("Noclip command only works for script owner", "error")
            return
        end
        
        State.noclip = true
        notification("Noclip enabled", "success")
        
    elseif cmd == "clip" then
        if executor ~= player then
            notification("Clip command only works for script owner", "error")
            return
        end
        
        State.noclip = false
        notification("Noclip disabled", "success")
        
    elseif cmd == "speed" or cmd == "ws" then
        local speed = tonumber(args[2]) or 16
        speed = math.clamp(speed, 0, 1000)
        
        if executor.Character and executor.Character:FindFirstChild("Humanoid") then
            executor.Character.Humanoid.WalkSpeed = speed
            notification("Walk speed set to " .. speed, "success")
        end
        
    elseif cmd == "jp" or cmd == "jumppower" then
        local power = tonumber(args[2]) or 50
        power = math.clamp(power, 0, 1000)
        
        if executor.Character and executor.Character:FindFirstChild("Humanoid") then
            executor.Character.Humanoid.JumpPower = power
            notification("Jump power set to " .. power, "success")
        end
        
    elseif cmd == "reset" then
        pcall(function()
            load:FireServer()
        end)
        notification("Character reset", "success")
        
    elseif cmd == "ff" or cmd == "fastfarm" then
        if executor ~= player then
            notification("Fast farm only works for script owner", "error")
            return
        end
        
        State.fastFarm = not State.fastFarm
        notification("Fast farm " .. (State.fastFarm and "enabled" or "disabled"), State.fastFarm and "success" or "info")
        
    elseif cmd == "sf" or cmd == "slowfarm" then
        if executor ~= player then
            notification("Slow farm only works for script owner", "error")
            return
        end
        
        State.slowFarm = not State.slowFarm
        notification("Slow farm " .. (State.slowFarm and "enabled" or "disabled"), State.slowFarm and "success" or "info")
        
    elseif cmd == "godmode" then
        if executor ~= player then
            notification("God mode only works for script owner", "error")
            return
        end
        
        State.godMode = not State.godMode
        notification("God mode " .. (State.godMode and "enabled" or "disabled"), State.godMode and "success" or "info")
        
    elseif cmd == "kaura" or cmd == "killaura" then
        if executor ~= player then
            notification("Kill aura only works for script owner", "error")
            return
        end
        
        State.killAura = not State.killAura
        notification("Kill aura " .. (State.killAura and "enabled" or "disabled"), State.killAura and "success" or "info")
        
    elseif cmd == "rejoin" then
        notification("Rejoining server...", "info")
        task.wait(1)
        pcall(function()
            TeleportService:Teleport(game.PlaceId, executor)
        end)
        
    else
        notification("Unknown command: " .. cmd, "error")
    end
end

-- Enhanced Chat Handler
local function setupChatHandler()
    local function handleCommand(executor, message)
        if not message or message == "" then return end
        
        if message:sub(1, 1) == Config.commandPrefix then
            local command = message:sub(2):match("^%s*(.-)%s*$") -- Trim whitespace
            if command ~= "" then
                debugPrint("Processing command: " .. command .. " from " .. executor.Name)
                executeCommand(command, executor)
            end
        end
    end
    
    -- Handle local player chat
    if Data.connections.localChat then
        Data.connections.localChat:Disconnect()
    end
    
    Data.connections.localChat = player.Chatted:Connect(function(message)
        handleCommand(player, message)
    end)
    
    -- Handle other players' chat
    local function connectPlayer(plr)
        if plr ~= player and not Data.connections["chat_" .. plr.UserId] then
            Data.connections["chat_" .. plr.UserId] = plr.Chatted:Connect(function(message)
                handleCommand(plr, message)
            end)
        end
    end
    
    -- Connect existing players
    for _, plr in pairs(Players:GetPlayers()) do
        connectPlayer(plr)
    end
    
    -- Connect new players
    if Data.connections.playerAdded then
        Data.connections.playerAdded:Disconnect()
    end
    
    Data.connections.playerAdded = Players.PlayerAdded:Connect(connectPlayer)
    
    -- Clean up when players leave
    if Data.connections.playerRemoving then
        Data.connections.playerRemoving:Disconnect()
    end
    
    Data.connections.playerRemoving = Players.PlayerRemoving:Connect(function(plr)
        if Data.connections["chat_" .. plr.UserId] then
            Data.connections["chat_" .. plr.UserId]:Disconnect()
            Data.connections["chat_" .. plr.UserId] = nil
        end
        
        -- Remove from admin list
        for i, adminName in pairs(Data.admins) do
            if adminName:lower() == plr.Name:lower() then
                table.remove(Data.admins, i)
                notification(plr.Name .. " (admin) left the server", "info")
                break
            end
        end
    end)
end

-- Create GUI
local function createGUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "2take1Hub"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    local success = pcall(function()
        screenGui.Parent = game:GetService("CoreGui")
    end)
    if not success then
        screenGui.Parent = player:WaitForChild("PlayerGui")
    end
    
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, 400, 0, 500)
    mainFrame.Position = UDim2.new(0.5, -200, 0, -600) -- Start off-screen
    mainFrame.BackgroundColor3 = Theme.background
    mainFrame.BorderSizePixel = 0
    mainFrame.ZIndex = 100
    mainFrame.Parent = screenGui
    
    local mainCorner = Instance.new("UICorner")
    mainCorner.CornerRadius = UDim.new(0, 12)
    mainCorner.Parent = mainFrame
    
    local mainStroke = Instance.new("UIStroke")
    mainStroke.Color = Theme.accent
    mainStroke.Thickness = 2
    mainStroke.Parent = mainFrame
    
    local header = Instance.new("Frame")
    header.Name = "Header"
    header.Size = UDim2.new(1, 0, 0, 40)
    header.BackgroundColor3 = Theme.secondary
    header.BorderSizePixel = 0
    header.ZIndex = 101
    header.Parent = mainFrame
    
    local headerCorner = Instance.new("UICorner")
    headerCorner.CornerRadius = UDim.new(0, 12)
    headerCorner.Parent = header
    
    local headerFix = Instance.new("Frame")
    headerFix.Size = UDim2.new(1, 0, 0, 12)
    headerFix.Position = UDim2.new(0, 0, 1, -12)
    headerFix.BackgroundColor3 = Theme.secondary
    headerFix.BorderSizePixel = 0
    headerFix.ZIndex = 101
    headerFix.Parent = header
    
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, -100, 1, 0)
    title.Position = UDim2.new(0, 15, 0, 0)
    title.BackgroundTransparency = 1
    title.Text = "2take1 Hub - Fixed"
    title.TextColor3 = Theme.text
    title.TextSize = 16
    title.Font = Enum.Font.GothamBold
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.ZIndex = 102
    title.Parent = header
    
    local minimizeButton = Instance.new("TextButton")
    minimizeButton.Name = "MinimizeButton"
    minimizeButton.Size = UDim2.new(0, 30, 0, 30)
    minimizeButton.Position = UDim2.new(1, -75, 0, 5)
    minimizeButton.BackgroundColor3 = Theme.warning
    minimizeButton.Text = "−"
    minimizeButton.TextColor3 = Theme.text
    minimizeButton.TextSize = 18
    minimizeButton.Font = Enum.Font.GothamBold
    minimizeButton.ZIndex = 102
    minimizeButton.Parent = header
    
    local minCorner = Instance.new("UICorner")
    minCorner.CornerRadius = UDim.new(0, 6)
    minCorner.Parent = minimizeButton
    
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -40, 0, 5)
    closeButton.BackgroundColor3 = Theme.danger
    closeButton.Text = "×"
    closeButton.TextColor3 = Theme.text
    closeButton.TextSize = 18
    closeButton.Font = Enum.Font.GothamBold
    closeButton.ZIndex = 102
    closeButton.Parent = header
    
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, 6)
    closeCorner.Parent = closeButton
    
    local contentFrame = Instance.new("ScrollingFrame")
    contentFrame.Name = "ContentFrame"
    contentFrame.Size = UDim2.new(1, -20, 1, -60)
    contentFrame.Position = UDim2.new(0, 10, 0, 50)
    contentFrame.BackgroundColor3 = Theme.secondary
    contentFrame.BorderSizePixel = 0
    contentFrame.ScrollBarThickness = 6
    contentFrame.ScrollBarImageColor3 = Theme.accent
    contentFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    contentFrame.ZIndex = 101
    contentFrame.Parent = mainFrame
    
    local contentCorner = Instance.new("UICorner")
    contentCorner.CornerRadius = UDim.new(0, 10)
    contentCorner.Parent = contentFrame
    
    local listLayout = Instance.new("UIListLayout")
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    listLayout.Padding = UDim.new(0, 10)
    listLayout.Parent = contentFrame
    
    local padding = Instance.new("UIPadding")
    padding.PaddingTop = UDim.new(0, 10)
    padding.PaddingLeft = UDim.new(0, 10)
    padding.PaddingRight = UDim.new(0, 10)
    padding.PaddingBottom = UDim.new(0, 10)
    padding.Parent = contentFrame
    
    return {
        screenGui = screenGui,
        mainFrame = mainFrame,
        header = header,
        closeButton = closeButton,
        minimizeButton = minimizeButton,
        contentFrame = contentFrame
    }
end

-- Create UI Elements
local function createToggle(text, parent, callback)
    local toggleFrame = Instance.new("Frame")
    toggleFrame.Size = UDim2.new(1, 0, 0, 40)
    toggleFrame.BackgroundColor3 = Theme.tertiary
    toggleFrame.BorderSizePixel = 0
    toggleFrame.ZIndex = 102
    toggleFrame.Parent = parent
    
    local toggleCorner = Instance.new("UICorner")
    toggleCorner.CornerRadius = UDim.new(0, 8)
    toggleCorner.Parent = toggleFrame
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, -70, 1, 0)
    label.Position = UDim2.new(0, 15, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = Theme.text
    label.TextSize = 14
    label.Font = Enum.Font.Gotham
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.ZIndex = 103
    label.Parent = toggleFrame
    
    local toggleButton = Instance.new("TextButton")
    toggleButton.Size = UDim2.new(0, 50, 0, 25)
    toggleButton.Position = UDim2.new(1, -60, 0.5, -12.5)
    toggleButton.BackgroundColor3 = Theme.background
    toggleButton.Text = ""
    toggleButton.ZIndex = 103
    toggleButton.Parent = toggleFrame
    
    local toggleBtnCorner = Instance.new("UICorner")
    toggleBtnCorner.CornerRadius = UDim.new(0, 12)
    toggleBtnCorner.Parent = toggleButton
    
    local indicator = Instance.new("Frame")
    indicator.Size = UDim2.new(0, 20, 0, 20)
    indicator.Position = UDim2.new(0, 2.5, 0, 2.5)
    indicator.BackgroundColor3 = Theme.text
    indicator.BorderSizePixel = 0
    indicator.ZIndex = 104
    indicator.Parent = toggleButton
    
    local indicatorCorner = Instance.new("UICorner")
    indicatorCorner.CornerRadius = UDim.new(0, 10)
    indicatorCorner.Parent = indicator
    
    local toggled = false
    
    toggleButton.MouseButton1Click:Connect(function()
        toggled = not toggled
        
        local newButtonColor = toggled and Theme.success or Theme.background
        local newIndicatorPos = toggled and UDim2.new(1, -22.5, 0, 2.5) or UDim2.new(0, 2.5, 0, 2.5)
        
        local btnTween = createTween(toggleButton, {BackgroundColor3 = newButtonColor})
        local indTween = createTween(indicator, {Position = newIndicatorPos})
        
        if btnTween then btnTween:Play() end
        if indTween then indTween:Play() end
        
        callback(toggled)
    end)
    
    return toggleFrame
end

local function createButton(text, parent, callback)
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(1, 0, 0, 40)
    button.BackgroundColor3 = Theme.accent
    button.Text = text
    button.TextColor3 = Theme.text
    button.TextSize = 14
    button.Font = Enum.Font.GothamBold
    button.BorderSizePixel = 0
    button.ZIndex = 102
    button.Parent = parent
    
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 8)
    buttonCorner.Parent = button
    
    button.MouseButton1Click:Connect(callback)
    
    button.MouseEnter:Connect(function()
        local tween = createTween(button, {BackgroundColor3 = Theme.accent:lerp(Color3.new(1, 1, 1), 0.1)})
        if tween then tween:Play() end
    end)
    
    button.MouseLeave:Connect(function()
        local tween = createTween(button, {BackgroundColor3 = Theme.accent})
        if tween then tween:Play() end
    end)
    
    return button
end

-- Initialize GUI
GUI = createGUI()

-- Create UI Elements
createToggle("Fast Farm", GUI.contentFrame, function(enabled)
    State.fastFarm = enabled
    executeCommand(enabled and "ff" or "ff", player)
end)

createToggle("Slow Farm", GUI.contentFrame, function(enabled)
    State.slowFarm = enabled
    executeCommand(enabled and "sf" or "sf", player)
end)

createToggle("God Mode", GUI.contentFrame, function(enabled)
    State.godMode = enabled
    executeCommand("godmode", player)
end)

createToggle("Kill Aura", GUI.contentFrame, function(enabled)
    State.killAura = enabled
    executeCommand("kaura", player)
end)

createToggle("Fly", GUI.contentFrame, function(enabled)
    if enabled then
        executeCommand("fly", player)
    else
        executeCommand("unfly", player)
    end
end)

createToggle("Noclip", GUI.contentFrame, function(enabled)
    if enabled then
        executeCommand("noclip", player)
    else
        executeCommand("clip", player)
    end
end)

-- Action Buttons
createButton("Kill All Players", GUI.contentFrame, function()
    executeCommand("kill all", player)
end)

createButton("God All Players", GUI.contentFrame, function()
    executeCommand("god all", player)
end)

createButton("Damage All 50%", GUI.contentFrame, function()
    executeCommand("dmg all 50", player)
end)

createButton("Damage All 25%", GUI.contentFrame, function()
    executeCommand("dmg all 25", player)
end)

createButton("Reset Character", GUI.contentFrame, function()
    executeCommand("reset", player)
end)

createButton("Rejoin Server", GUI.contentFrame, function()
    executeCommand("rejoin", player)
end)

-- Update content size
local function updateContentSize()
    local contentSize = GUI.contentFrame.UIListLayout.AbsoluteContentSize.Y + 20
    GUI.contentFrame.CanvasSize = UDim2.new(0, 0, 0, contentSize)
end

-- Wait for layout to update
task.wait(0.1)
updateContentSize()

-- GUI Events
GUI.closeButton.MouseButton1Click:Connect(function()
    local tween = createTween(GUI.mainFrame, {Position = UDim2.new(0.5, -200, 0, -600)}, 0.5)
    if tween then 
        tween:Play()
        tween.Completed:Connect(function()
            safeDestroy(GUI.screenGui)
            State.guiOpen = false
        end)
    else
        safeDestroy(GUI.screenGui)
        State.guiOpen = false
    end
end)

GUI.minimizeButton.MouseButton1Click:Connect(function()
    local isMinimized = GUI.contentFrame.Visible
    GUI.contentFrame.Visible = not isMinimized
    
    local newSize = isMinimized and UDim2.new(0, 400, 0, 50) or UDim2.new(0, 400, 0, 500)
    local tween = createTween(GUI.mainFrame, {Size = newSize})
    if tween then tween:Play() end
    
    GUI.minimizeButton.Text = isMinimized and "+" or "−"
end)

-- Dragging functionality
local dragging = false
local dragStart = nil
local startPos = nil

GUI.header.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = GUI.mainFrame.Position
    end
end)

UIS.InputChanged:Connect(function(input)
    if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local delta = input.Position - dragStart
        GUI.mainFrame.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end
end)

UIS.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = false
    end
end)

-- Hotkeys
local hotkeys = {
    [Enum.KeyCode.F1] = function() executeCommand("ff", player) end,
    [Enum.KeyCode.F2] = function() executeCommand("sf", player) end,
    [Enum.KeyCode.F3] = function() executeCommand("godmode", player) end,
    [Enum.KeyCode.F4] = function() executeCommand("kaura", player) end,
    [Enum.KeyCode.F5] = function() executeCommand(State.flying and "unfly" or "fly", player) end,
    [Enum.KeyCode.F6] = function() executeCommand(State.noclip and "clip" or "noclip", player) end,
    [Enum.KeyCode.Delete] = function() executeCommand("kill all", player) end,
    [Enum.KeyCode.Insert] = function() executeCommand("god all", player) end,
}

UIS.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed or State.focused then return end
    
    if hotkeys[input.KeyCode] then
        hotkeys[input.KeyCode]()
    end
end)

-- Main Loop
local frameCount = 0
Data.connections.mainLoop = RunService.Heartbeat:Connect(function()
    frameCount = frameCount + 1
    
    if not State.guiOpen or not player.Character then return end
    
    local character = player.Character
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    
    if not humanoid or not rootPart then return end
    
    -- Fast Farm
    if State.fastFarm and frameCount % 3 == 0 then
        local handle = getSwordHandle()
        if handle and handle:FindFirstChild("up") then
            pcall(function()
                for i = 1, Config.speed do
                    handle.up.RemoteEvent:FireServer()
                end
            end)
        end
    end
    
    -- Slow Farm
    if State.slowFarm and frameCount % 10 == 0 then
        local handle = getSwordHandle()
        if handle and handle:FindFirstChild("up") then
            pcall(function()
                for i = 1, 2 do
                    handle.up.RemoteEvent:FireServer()
                end
            end)
        end
    end
    
    -- God Mode
    if State.godMode then
        local pvp = character:FindFirstChild("pvp")
        if pvp then
            safeDestroy(pvp)
        end
    end
    
    -- Kill Aura
    if State.killAura and frameCount % 30 == 0 then
        local handle = getSwordHandle()
        if handle and handle:FindFirstChild("dmg") then
            pcall(function()
                for _, target in pairs(workspace:GetChildren()) do
                    if target:FindFirstChild("Humanoid") and target:FindFirstChild("HumanoidRootPart") and target.Name ~= player.Name then
                        local targetHumanoid = target.Humanoid
                        local targetRoot = target.HumanoidRootPart
                        
                        if targetHumanoid.Health > 0 then
                            local distance = (rootPart.Position - targetRoot.Position).Magnitude
                            if distance <= Config.range then
                                handle.dmg.RemoteEvent:FireServer(targetHumanoid, 1000)
                            end
                        end
                    end
                end
            end)
        end
    end
    
    -- Noclip
    if State.noclip and frameCount % 5 == 0 then
        pcall(function()
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end)
    end
end)

-- Character respawn handling
Data.connections.characterAdded = player.CharacterAdded:Connect(function(character)
    task.wait(1)
    
    local humanoid = character:WaitForChild("Humanoid", 5)
    if humanoid then
        humanoid.WalkSpeed = Config.walkSpeed
        humanoid.JumpPower = Config.jumpPower
    end
    
    -- Reapply states
    if State.godMode then
        task.spawn(function()
            task.wait(0.5)
            local pvp = character:FindFirstChild("pvp")
            if pvp then
                safeDestroy(pvp)
            end
        end)
    end
    
    if State.noclip then
        task.spawn(function()
            task.wait(0.5)
            executeCommand("noclip", player)
        end)
    end
end)

-- Setup chat handler
setupChatHandler()

-- Startup animation and notifications
task.spawn(function()
    -- Animate GUI in
    local tween = createTween(GUI.mainFrame, {Position = UDim2.new(0.5, -200, 0.5, -250)}, 0.8)
    if tween then tween:Play() end
    
    task.wait(1)
    notification("2take1 Hub loaded successfully!", "success")
    
    task.wait(2)
    notification("Type '" .. Config.commandPrefix .. "cmds' for all commands", "info")
    
    task.wait(2)
    notification("Hotkeys: F1-F6 for toggles | DEL=Kill All | INS=God All", "info")
    
    State.initialized = true
    debugPrint("Script initialized successfully")
end)

-- Cleanup function
local function cleanup()
    for _, connection in pairs(Data.connections) do
        if connection then
            connection:Disconnect()
        end
    end
    
    for _, obj in pairs(Data.flyObjects) do
        safeDestroy(obj)
    end
    
    if GUI.screenGui then
        safeDestroy(GUI.screenGui)
    end
end

-- Auto-cleanup on script end
game:BindToClose(cleanup)
